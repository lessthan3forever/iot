/**
 * amis-ui v2.9.0
 * Copyright 2018-2023 fex
 */

import { __extends, __spreadArray, __read, __decorate, __metadata } from 'tslib';
import React__default from 'react';
import { eachTree, parse, autobind, uncontrollable, themeable, localeable } from 'amis-core';
import { doc } from 'amis-formula/lib/doc';
import { FormulaPlugin, editorFactory } from './plugin.js';
import FuncList from './FuncList.js';
import VariableList from './VariableList.js';
import { CodeMirrorEditor } from '../CodeMirror.js';
import { toast } from '../Toast.js';

var FormulaEditor = /** @class */ (function (_super) {
    __extends(FormulaEditor, _super);
    function FormulaEditor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            focused: false
        };
        return _this;
    }
    FormulaEditor.buildDefaultFunctions = function (doc) {
        var funcs = [];
        doc.forEach(function (item) {
            var namespace = item.namespace || 'Others';
            var exists = funcs.find(function (item) { return item.groupName === namespace; });
            if (!exists) {
                exists = {
                    groupName: namespace,
                    items: []
                };
                funcs.push(exists);
            }
            exists.items.push(item);
        });
        return funcs;
    };
    FormulaEditor.replaceStrByIndex = function (str, idx, key, replaceKey) {
        var from = str.slice(0, idx);
        var left = str.slice(idx);
        return from + left.replace(key, replaceKey);
    };
    FormulaEditor.getRegExpByMode = function (evalMode, key) {
        var reg = evalMode
            ? "\\b".concat(key, "\\b")
            : "\\$\\{[^\\{\\}]*\\b".concat(key, "\\b[^\\{\\}]*\\}");
        return new RegExp(reg);
    };
    FormulaEditor.highlightValue = function (value, variables, evalMode) {
        if (evalMode === void 0) { evalMode = true; }
        if (!Array.isArray(variables) || !variables.length || !value) {
            return;
        }
        var varMap = {};
        eachTree(variables, function (item) {
            if (item.value) {
                var key = item.value;
                varMap[key] = item.label;
            }
        });
        var vars = Object.keys(varMap)
            .filter(function (item) { return item; })
            .sort(function (a, b) { return b.length - a.length; });
        var content = value || '';
        var html = '';
        // 标记方法调用
        html = content.replace(/([A-Z]+)\s*\(/g, function (_, func, pos) {
            return _ === null || _ === void 0 ? void 0 : _.replace(func, "<span class=\"c-func\">".concat(func, "</span>"));
        });
        var REPLACE_KEY = 'AMIS_FORMULA_REPLACE_KEY';
        vars.forEach(function (v) {
            var from = 0;
            var idx = -1;
            while (~(idx = content.indexOf(v, from))) {
                var encodeHtml = FormulaEditor.replaceStrByIndex(html, idx, v, REPLACE_KEY);
                var reg = FormulaEditor.getRegExpByMode(evalMode, REPLACE_KEY);
                // 如果匹配到则高亮，没有匹配到替换成原值
                if (reg.test(encodeHtml)) {
                    html = encodeHtml.replace(REPLACE_KEY, "<span class=\"c-field\">".concat(varMap[v], "</span>"));
                }
                else {
                    html = encodeHtml.replace(REPLACE_KEY, v);
                }
                from = idx + v.length;
            }
        });
        return { html: html };
    };
    FormulaEditor.prototype.componentWillUnmount = function () {
        var _a;
        (_a = this.editorPlugin) === null || _a === void 0 ? void 0 : _a.dispose();
    };
    FormulaEditor.prototype.handleFocus = function () {
        this.setState({
            focused: true
        });
    };
    FormulaEditor.prototype.handleBlur = function () {
        this.setState({
            focused: false
        });
    };
    FormulaEditor.prototype.insertValue = function (value, type) {
        var _a;
        (_a = this.editorPlugin) === null || _a === void 0 ? void 0 : _a.insertContent(value, type);
    };
    FormulaEditor.prototype.handleEditorMounted = function (cm, editor) {
        var _this = this;
        this.editorPlugin = new FormulaPlugin(editor, cm, function () { return _this.props; });
    };
    FormulaEditor.prototype.validate = function () {
        var value = this.props.value;
        try {
            value
                ? parse(value, {
                    evalMode: this.props.evalMode
                })
                : null;
        }
        catch (e) {
            return e.message;
        }
        return;
    };
    FormulaEditor.prototype.handleFunctionSelect = function (item) {
        var _a;
        (_a = this.editorPlugin) === null || _a === void 0 ? void 0 : _a.insertContent("".concat(item.name), 'func');
    };
    FormulaEditor.prototype.handleVariableSelect = function (item) {
        var _a;
        var _b = this.props; _b.evalMode; var selfVariableName = _b.selfVariableName;
        if (item &&
            item.value &&
            selfVariableName &&
            selfVariableName === item.value) {
            toast.warning('不能使用当前变量[self]，避免循环引用。');
            return;
        }
        if (!item.value) {
            return;
        }
        (_a = this.editorPlugin) === null || _a === void 0 ? void 0 : _a.insertContent({
            key: item.value,
            name: item.label
        }, 'variable');
    };
    FormulaEditor.prototype.handleOnChange = function (value) {
        var onChange = this.props.onChange;
        onChange === null || onChange === void 0 ? void 0 : onChange(value);
    };
    FormulaEditor.prototype.editorFactory = function (dom, cm) {
        return editorFactory(dom, cm, this.props);
    };
    FormulaEditor.prototype.render = function () {
        var _a = this.props, variables = _a.variables, header = _a.header, value = _a.value, functions = _a.functions, variableMode = _a.variableMode, __ = _a.translate, cx = _a.classnames, variableClassName = _a.variableClassName, functionClassName = _a.functionClassName, classPrefix = _a.classPrefix, selfVariableName = _a.selfVariableName;
        var focused = this.state.focused;
        var customFunctions = Array.isArray(functions) ? functions : [];
        var functionList = __spreadArray(__spreadArray([], __read(FormulaEditor.buildDefaultFunctions(doc)), false), __read(customFunctions), false);
        return (React__default.createElement("div", { className: cx("FormulaEditor", {
                'is-focused': focused
            }) },
            React__default.createElement("section", { className: cx("FormulaEditor-content") },
                React__default.createElement("header", { className: cx("FormulaEditor-header") }, __(header || 'FormulaEditor.title')),
                React__default.createElement(CodeMirrorEditor, { className: cx('FormulaEditor-editor'), value: value, onChange: this.handleOnChange, editorFactory: this.editorFactory, editorDidMount: this.handleEditorMounted, onFocus: this.handleFocus, onBlur: this.handleBlur })),
            React__default.createElement("section", { className: cx('FormulaEditor-settings') },
                React__default.createElement("div", { className: cx('FormulaEditor-panel') },
                    variableMode !== 'tabs' ? (React__default.createElement("div", { className: cx('FormulaEditor-panel-header') }, __('FormulaEditor.variable'))) : null,
                    React__default.createElement("div", { className: cx('FormulaEditor-panel-body', variableMode && "FormulaEditor-panel-body--".concat(variableMode)) },
                        React__default.createElement(VariableList, { classPrefix: classPrefix, className: cx('FormulaEditor-VariableList', 'FormulaEditor-VariableList-root', variableClassName), selectMode: variableMode, data: variables, onSelect: this.handleVariableSelect, selfVariableName: selfVariableName }))),
                React__default.createElement(FuncList, { className: functionClassName, title: __('FormulaEditor.function'), data: functionList, onSelect: this.handleFunctionSelect }))));
    };
    FormulaEditor.defaultProps = {
        variables: [],
        evalMode: true
    };
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], FormulaEditor.prototype, "handleFocus", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], FormulaEditor.prototype, "handleBlur", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, String]),
        __metadata("design:returntype", void 0)
    ], FormulaEditor.prototype, "insertValue", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object]),
        __metadata("design:returntype", void 0)
    ], FormulaEditor.prototype, "handleEditorMounted", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], FormulaEditor.prototype, "validate", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], FormulaEditor.prototype, "handleFunctionSelect", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], FormulaEditor.prototype, "handleVariableSelect", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], FormulaEditor.prototype, "handleOnChange", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [HTMLElement, Object]),
        __metadata("design:returntype", void 0)
    ], FormulaEditor.prototype, "editorFactory", null);
    return FormulaEditor;
}(React__default.Component));
var Editor = uncontrollable(themeable(localeable(FormulaEditor)), {
    value: 'onChange'
}, ['validate']);

export { FormulaEditor, Editor as default };
