/**
 * amis-ui v2.9.0
 * Copyright 2018-2023 fex
 */

import { __generator, __extends, __awaiter, __rest, __assign } from 'tslib';
import React__default from 'react';
import hoistNonReactStatic from 'hoist-non-react-statics';
import debounce from 'lodash/debounce';
import { types, flow, isAlive } from 'mobx-state-tree';
import { normalizeApiResponseData, isPureVariable, resolveVariableAndFilter, isEffectiveApi, normalizeApi, tokenize, buildApi, createObject, isObject, findTreeIndex, EnvContext } from 'amis-core';
import { reaction } from 'mobx';
import { withStore } from './WithStore.js';

var Store = types
    .model('RemoteConfigStore')
    .props({
    fetching: false,
    errorMsg: '',
    config: types.frozen(),
    data: types.frozen({})
})
    .actions(function (self) {
    var component = undefined;
    var load = flow(function (env, api, ctx, config) {
        var ret, data, options, e_1;
        var _a;
        if (config === void 0) { config = {}; }
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, 3, 4]);
                    self.fetching = true;
                    return [4 /*yield*/, env.fetcher(api, ctx)];
                case 1:
                    ret = _b.sent();
                    if (!isAlive(self)) {
                        return [2 /*return*/];
                    }
                    if (ret.ok) {
                        data = normalizeApiResponseData(ret.data);
                        options = config.adaptor
                            ? config.adaptor(data, component.props)
                            : data;
                        self.setConfig(options, config, 'remote');
                        (_a = config.afterLoad) === null || _a === void 0 ? void 0 : _a.call(config, data, self.config, component.props);
                        return [2 /*return*/, ret];
                    }
                    else {
                        throw new Error(ret.msg || 'fetch error');
                    }
                case 2:
                    e_1 = _b.sent();
                    isAlive(self) && (self.errorMsg = e_1.message);
                    return [3 /*break*/, 4];
                case 3:
                    isAlive(self) && (self.fetching = false);
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/];
            }
        });
    });
    return {
        setComponent: function (c) {
            component = c;
        },
        load: load,
        setData: function (data) {
            self.data = data || {};
        },
        setConfig: function (options, config, motivation) {
            if (config.normalizeConfig) {
                options =
                    config.normalizeConfig(options, self.config, component.props, motivation) || options;
            }
            self.config = options;
        }
    };
});
function withRemoteConfig(config) {
    if (config === void 0) { config = {}; }
    return function (ComposedComponent) {
        var _a;
        var result = hoistNonReactStatic(withStore(function () { return Store.create(); })((_a = /** @class */ (function (_super) {
                __extends(class_1, _super);
                function class_1(props) {
                    var _this = this;
                    var _a;
                    _this = _super.call(this, props) || this;
                    _this.toDispose = [];
                    _this.loadOptions = debounce(_this.loadAutoComplete.bind(_this), 250, {
                        trailing: true,
                        leading: false
                    });
                    _this.setConfig = _this.setConfig.bind(_this);
                    props.store.setComponent(_this);
                    _this.deferLoadConfig = _this.deferLoadConfig.bind(_this);
                    (_a = props.remoteConfigRef) === null || _a === void 0 ? void 0 : _a.call(props, _this);
                    props.store.setData(props.data);
                    _this.syncConfig();
                    return _this;
                }
                class_1.prototype.componentDidMount = function () {
                    var _this = this;
                    var env = this.props.env || this.context;
                    var _a = this.props, store = _a.store, data = _a.data;
                    var source = this.props[config.sourceField || 'source'];
                    if (isPureVariable(source)) {
                        this.toDispose.push(reaction(function () {
                            return resolveVariableAndFilter(source, store.data, '| raw');
                        }, function () { return _this.syncConfig(); }));
                    }
                    else if (env && isEffectiveApi(source, data)) {
                        this.loadConfig();
                        source.autoRefresh !== false &&
                            this.toDispose.push(reaction(function () {
                                var api = normalizeApi(source);
                                return api.trackExpression
                                    ? tokenize(api.trackExpression, store.data)
                                    : buildApi(api, store.data, {
                                        ignoreData: true
                                    }).url;
                            }, function () { return _this.loadConfig(); }));
                    }
                };
                class_1.prototype.componentDidUpdate = function (prevProps) {
                    var props = this.props;
                    if (props.data !== prevProps.data) {
                        props.store.setData(props.data);
                    }
                };
                class_1.prototype.componentWillUnmount = function () {
                    var _a, _b;
                    this.toDispose.forEach(function (fn) { return fn(); });
                    this.toDispose = [];
                    (_b = (_a = this.props).remoteConfigRef) === null || _b === void 0 ? void 0 : _b.call(_a, undefined);
                    this.loadOptions.cancel();
                };
                class_1.prototype.loadConfig = function (ctx) {
                    if (ctx === void 0) { ctx = this.props.data; }
                    return __awaiter(this, void 0, void 0, function () {
                        var env, store, source;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    env = this.props.env || this.context;
                                    store = this.props.store;
                                    source = this.props[config.sourceField || 'source'];
                                    if (!(env && isEffectiveApi(source, ctx))) return [3 /*break*/, 2];
                                    return [4 /*yield*/, store.load(env, source, ctx, config)];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    });
                };
                class_1.prototype.loadAutoComplete = function (input) {
                    var env = this.props.env || this.context;
                    var _a = this.props, autoComplete = _a.autoComplete, data = _a.data, store = _a.store;
                    if (!env || !env.fetcher) {
                        throw new Error('fetcher is required');
                    }
                    var ctx = createObject(data, {
                        term: input,
                        value: input
                    });
                    if (!isEffectiveApi(autoComplete, ctx)) {
                        return Promise.resolve({
                            options: []
                        });
                    }
                    return store.load(env, autoComplete, ctx, config);
                };
                class_1.prototype.setConfig = function (value, ctx) {
                    var store = this.props.store;
                    store.setConfig(value, config, ctx);
                };
                class_1.prototype.syncConfig = function () {
                    var _a = this.props, store = _a.store, data = _a.data;
                    var source = this.props[config.sourceField || 'source'];
                    if (isPureVariable(source)) {
                        store.setConfig(resolveVariableAndFilter(source, data, '| raw') || [], config, 'syncConfig');
                    }
                    else if (isObject(source) && !isEffectiveApi(source, data)) {
                        store.setConfig(source, config, 'syncConfig');
                    }
                };
                class_1.prototype.deferLoadConfig = function (item) {
                    var _a, _b;
                    return __awaiter(this, void 0, void 0, function () {
                        var _c, store, data, deferApi, source, env, indexes, ret, response, e_2, ret2;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    _c = this.props, store = _c.store, data = _c.data, deferApi = _c.deferApi;
                                    source = this.props[config.sourceField || 'source'];
                                    env = this.props.env || this.context;
                                    indexes = findTreeIndex(store.config, function (a) { return a === item; });
                                    ret = (_a = config.beforeDeferLoad) === null || _a === void 0 ? void 0 : _a.call(config, item, indexes, store.config, this.props);
                                    ret && store.setConfig(ret, config, 'before-defer-load');
                                    _d.label = 1;
                                case 1:
                                    _d.trys.push([1, 3, , 4]);
                                    if (!isEffectiveApi(item.deferApi || deferApi || source)) {
                                        throw new Error('deferApi is required');
                                    }
                                    return [4 /*yield*/, env.fetcher(item.deferApi || deferApi || source, createObject(data, item))];
                                case 2:
                                    response = _d.sent();
                                    return [3 /*break*/, 4];
                                case 3:
                                    e_2 = _d.sent();
                                    response = {
                                        ok: false,
                                        msg: e_2.message,
                                        status: 500,
                                        data: undefined
                                    };
                                    return [3 /*break*/, 4];
                                case 4: return [4 /*yield*/, ((_b = config.afterDeferLoad) === null || _b === void 0 ? void 0 : _b.call(config, item, indexes, // 只能假定还是那个 index 了
                                    response, store.config, this.props))];
                                case 5:
                                    ret2 = _d.sent();
                                    ret2 && store.setConfig(ret2, config, 'after-defer-load');
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                class_1.prototype.render = function () {
                    var store = this.props.store;
                    var env = this.props.env || this.context;
                    var injectedProps = {
                        config: store.config,
                        loading: store.fetching,
                        deferLoad: this.deferLoadConfig,
                        updateConfig: this.setConfig
                    };
                    var _a = this.props; _a.remoteConfigRef; var autoComplete = _a.autoComplete, rest = __rest(_a, ["remoteConfigRef", "autoComplete"]);
                    return (React__default.createElement(ComposedComponent, __assign({}, rest, (env && isEffectiveApi(autoComplete) && this.loadOptions
                        ? { loadOptions: this.loadOptions }
                        : {}), (config.injectedPropsFilter
                        ? config.injectedPropsFilter(injectedProps, this.props)
                        : injectedProps))));
                };
                return class_1;
            }(React__default.Component)),
            _a.displayName = "WithRemoteConfig(".concat(ComposedComponent.displayName || ComposedComponent.name, ")"),
            _a.ComposedComponent = ComposedComponent,
            _a.contextType = EnvContext,
            _a)), ComposedComponent);
        return result;
    };
}

export { Store, withRemoteConfig };
