/**
 * amis-ui v2.9.0
 * Copyright 2018-2023 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var objectSpread2 = require('../../../@babel/runtime/helpers/esm/objectSpread2.js');
var ref = require('../../../rc-util/es/ref.js');
var React = require('react');
var findDOMNode = require('../../../rc-util/es/Dom/findDOMNode.js');
var observerUtil = require('../utils/observerUtil.js');
var DomWrapper = require('./DomWrapper.js');
var Collection = require('../Collection.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function SingleObserver(props, ref$1) {
  var children = props.children,
    disabled = props.disabled;
  var elementRef = React__namespace.useRef(null);
  var wrapperRef = React__namespace.useRef(null);
  var onCollectionResize = React__namespace.useContext(Collection.CollectionContext);
  // =========================== Children ===========================
  var isRenderProps = typeof children === 'function';
  var mergedChildren = isRenderProps ? children(elementRef) : children;
  // ============================= Size =============================
  var sizeRef = React__namespace.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  });
  // ============================= Ref ==============================
  var canRef = !isRenderProps && /*#__PURE__*/React__namespace.isValidElement(mergedChildren) && ref.supportRef(mergedChildren);
  var originRef = canRef ? mergedChildren.ref : null;
  var mergedRef = React__namespace.useMemo(function () {
    return ref.composeRef(originRef, elementRef);
  }, [originRef, elementRef]);
  var getDom = function getDom() {
    return findDOMNode["default"](elementRef.current) || findDOMNode["default"](wrapperRef.current);
  };
  React__namespace.useImperativeHandle(ref$1, function () {
    return getDom();
  });
  // =========================== Observe ============================
  var propsRef = React__namespace.useRef(props);
  propsRef.current = props;
  // Handler
  var onInternalResize = React__namespace.useCallback(function (target) {
    var _propsRef$current = propsRef.current,
      onResize = _propsRef$current.onResize,
      data = _propsRef$current.data;
    var _target$getBoundingCl = target.getBoundingClientRect(),
      width = _target$getBoundingCl.width,
      height = _target$getBoundingCl.height;
    var offsetWidth = target.offsetWidth,
      offsetHeight = target.offsetHeight;
    /**
     * Resize observer trigger when content size changed.
     * In most case we just care about element size,
     * let's use `boundary` instead of `contentRect` here to avoid shaking.
     */
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      var size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth: offsetWidth,
        offsetHeight: offsetHeight
      };
      sizeRef.current = size;
      // IE is strange, right?
      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      var sizeInfo = objectSpread2["default"](objectSpread2["default"]({}, size), {}, {
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      });
      // Let collection know what happened
      onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data);
      if (onResize) {
        // defer the callback but not defer to next frame
        Promise.resolve().then(function () {
          onResize(sizeInfo, target);
        });
      }
    }
  }, []);
  // Dynamic observe
  React__namespace.useEffect(function () {
    var currentElement = getDom();
    if (currentElement && !disabled) {
      observerUtil.observe(currentElement, onInternalResize);
    }
    return function () {
      return observerUtil.unobserve(currentElement, onInternalResize);
    };
  }, [elementRef.current, disabled]);
  // ============================ Render ============================
  return /*#__PURE__*/React__namespace.createElement(DomWrapper["default"], {
    ref: wrapperRef
  }, canRef ? /*#__PURE__*/React__namespace.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren);
}
var RefSingleObserver = /*#__PURE__*/React__namespace.forwardRef(SingleObserver);
if (process.env.NODE_ENV !== 'production') {
  RefSingleObserver.displayName = 'SingleObserver';
}

exports["default"] = RefSingleObserver;
