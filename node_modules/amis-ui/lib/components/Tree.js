/**
 * amis-ui v2.9.0
 * Copyright 2018-2023 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var amisCore = require('amis-core');
var Select = require('./Select.js');
var icons = require('./icons.js');
var Checkbox = require('./Checkbox.js');
var Spinner = require('./Spinner.js');
var index = require('./virtual-list/index.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/**
 * @file Tree
 * @description 树形组件
 *
 * 情况列举：
 * 1. 选中父节点时，连带选中子节点 : autoChildren = true 前提条件
 *    1.1 交互
 *        1.1.1 子节点不可以取消勾选 cascade = false,
 *        1.1.2 子节点可以取消勾选 cascade = true, withChildren 失效
 *    1.2 数据（state.value）
 *        1.2.1 只提交父节点数据 cascade = false
 *        1.2.2 只提交子节点的数据  onlyChildren = true
 *        1.2.3 全部数据提交 withChildren = true || cascade = true
 *
 * 2. 选中节点时，只选中当前节点，没有联动效果
 *
 * @author fex
 */
var TreeSelector = /** @class */ (function (_super) {
    tslib.__extends(TreeSelector, _super);
    function TreeSelector(props) {
        var _this = _super.call(this, props) || this;
        // 展开的节点
        _this.unfolded = new WeakMap();
        // key: child option, value: parent option;
        _this.relations = new WeakMap();
        _this.startPoint = {
            x: 0,
            y: 0
        };
        _this.root = React__default["default"].createRef();
        _this.state = {
            value: Select.value2array(props.value, {
                multiple: props.multiple,
                delimiter: props.delimiter,
                valueField: props.valueField,
                labelField: props.labelField,
                options: props.options,
                pathSeparator: props.pathSeparator
            }, props.enableNodePath),
            flattenedOptions: [],
            inputValue: '',
            addingParent: null,
            isAdding: false,
            isEditing: false,
            editingItem: null,
            dropIndicator: undefined
        };
        _this.syncUnFolded(props);
        _this.flattenOptions(props, true);
        return _this;
    }
    TreeSelector.prototype.componentDidMount = function () {
        var _a, _b;
        var enableNodePath = this.props.enableNodePath;
        // onRef只有渲染器的情况才会使用
        (_b = (_a = this.props).onRef) === null || _b === void 0 ? void 0 : _b.call(_a, this);
        enableNodePath && this.expandLazyLoadNodes();
    };
    TreeSelector.prototype.componentDidUpdate = function (prevProps) {
        var props = this.props;
        if (prevProps.options !== props.options) {
            this.syncUnFolded(props);
            this.flattenOptions(props);
        }
        if (prevProps.value !== props.value ||
            prevProps.options !== props.options) {
            this.setState({
                value: Select.value2array(props.value, {
                    multiple: props.multiple,
                    delimiter: props.delimiter,
                    valueField: props.valueField,
                    pathSeparator: props.pathSeparator,
                    options: props.options,
                    labelField: props.labelField
                }, props.enableNodePath)
            });
        }
    };
    /**
     * 展开懒加载节点的父节点
     */
    TreeSelector.prototype.expandLazyLoadNodes = function () {
        var _a = this.props, pathSeparator = _a.pathSeparator, onExpandTree = _a.onExpandTree, _b = _a.nodePath, nodePath = _b === void 0 ? [] : _b;
        var nodePathArr = nodePath.map(function (path) {
            return path ? path.toString().split(pathSeparator) : [];
        });
        onExpandTree === null || onExpandTree === void 0 ? void 0 : onExpandTree(nodePathArr);
    };
    TreeSelector.prototype.syncUnFolded = function (props, unfoldedLevel) {
        // 传入默认展开层级需要重新初始化unfolded
        var initFoldedLevel = typeof unfoldedLevel !== 'undefined';
        var expandLevel = Number(initFoldedLevel ? unfoldedLevel : props.unfoldedLevel) - 1;
        // 初始化树节点的展开状态
        var unfolded = this.unfolded;
        var _a = this.props, foldedField = _a.foldedField, unfoldedField = _a.unfoldedField;
        amisCore.eachTree(props.options, function (node, index, level) {
            if (unfolded.has(node) && !initFoldedLevel) {
                return;
            }
            if (node.children && node.children.length) {
                var ret = true;
                if (node.defer &&
                    node.loaded &&
                    !initFoldedLevel &&
                    unfoldedField &&
                    node[unfoldedField] !== false) {
                    ret = true;
                }
                else if (unfoldedField &&
                    typeof node[unfoldedField] !== 'undefined') {
                    ret = !!node[unfoldedField];
                }
                else if (foldedField && typeof node[foldedField] !== 'undefined') {
                    ret = !node[foldedField];
                }
                else {
                    ret = !!props.initiallyOpen && !initFoldedLevel;
                    if (!ret && level <= expandLevel) {
                        ret = true;
                    }
                }
                unfolded.set(node, ret);
            }
        });
        initFoldedLevel && this.forceUpdate();
        return unfolded;
    };
    TreeSelector.prototype.toggleUnfolded = function (node) {
        var unfolded = this.unfolded;
        var _a = this.props, onDeferLoad = _a.onDeferLoad, unfoldedField = _a.unfoldedField;
        if (node.defer && !node.loaded) {
            onDeferLoad === null || onDeferLoad === void 0 ? void 0 : onDeferLoad(node);
            return;
        }
        // ！ hack: 在node上直接添加属性，options 在更新的时候旧的字段会保留
        if (node.defer && node.loaded) {
            node[unfoldedField] = !unfolded.get(node);
        }
        unfolded.set(node, !unfolded.get(node));
        this.flattenOptions();
        this.forceUpdate();
    };
    TreeSelector.prototype.isUnfolded = function (node) {
        var unfolded = this.unfolded;
        var parent = this.relations.get(node);
        if (parent) {
            return !!unfolded.get(node) && this.isUnfolded(parent);
        }
        return !!unfolded.get(node);
    };
    TreeSelector.prototype.clearSelect = function () {
        var _this = this;
        this.setState({
            value: []
        }, function () {
            var _a = _this.props, joinValues = _a.joinValues, rootValue = _a.rootValue, onChange = _a.onChange;
            onChange(joinValues ? rootValue : []);
        });
    };
    /**
     * enableNodePath为true时，将label和value转换成node path格式
     */
    TreeSelector.prototype.transform2NodePath = function (value) {
        var _a = this.props, multiple = _a.multiple, options = _a.options, valueField = _a.valueField, labelField = _a.labelField, joinValues = _a.joinValues, extractValue = _a.extractValue, pathSeparator = _a.pathSeparator, delimiter = _a.delimiter;
        var nodesValuePath = [];
        var selectedNodes = Array.isArray(value) ? value.concat() : [value];
        var selectedNodesPath = selectedNodes.map(function (node) {
            var _a, _b;
            var _c;
            var nodePath = (_c = amisCore.getTreeAncestors(options, node, true)) === null || _c === void 0 ? void 0 : _c.reduce(function (acc, node) {
                acc[labelField].push(node[labelField]);
                acc[valueField].push(node[valueField]);
                return acc;
            }, (_a = {}, _a[labelField] = [], _a[valueField] = [], _a));
            var nodeValuePath = nodePath[valueField].join(pathSeparator);
            nodesValuePath.push(nodeValuePath);
            return tslib.__assign(tslib.__assign({}, node), (_b = {}, _b[labelField] = nodePath[labelField].join(pathSeparator), _b[valueField] = nodeValuePath, _b));
        });
        if (multiple) {
            return joinValues
                ? nodesValuePath.join(delimiter)
                : extractValue
                    ? nodesValuePath
                    : selectedNodesPath;
        }
        else {
            return joinValues || extractValue
                ? selectedNodesPath[0][valueField]
                : selectedNodesPath[0];
        }
    };
    TreeSelector.prototype.handleSelect = function (node, value) {
        var _this = this;
        var _a = this.props, joinValues = _a.joinValues, valueField = _a.valueField, onChange = _a.onChange, enableNodePath = _a.enableNodePath, onlyLeaf = _a.onlyLeaf;
        if (node[valueField] === undefined) {
            if (node.defer && !node.loaded) {
                this.toggleUnfolded(node);
            }
            return;
        }
        if (onlyLeaf && node.children) {
            return;
        }
        this.setState({
            value: [node]
        }, function () {
            onChange(enableNodePath
                ? _this.transform2NodePath(node)
                : joinValues
                    ? node[valueField]
                    : node);
        });
    };
    TreeSelector.prototype.handleCheck = function (item, checked) {
        var _this = this;
        // TODO: 重新梳理这里的逻辑
        var props = this.props;
        var value = this.state.value.concat();
        var idx = value.indexOf(item);
        var onlyChildren = props.onlyChildren, withChildren = props.withChildren, cascade = props.cascade, autoCheckChildren = props.autoCheckChildren;
        if (checked) {
            ~idx || value.push(item);
            // cascade 为 true 表示父节点跟子节点没有级联关系。
            if (autoCheckChildren) {
                var children = item.children ? item.children.concat([]) : [];
                if (onlyChildren) {
                    // 父级选中的时候，子节点也都选中，但是自己不选中
                    !~idx && children.length && value.pop();
                    while (children.length) {
                        var child = children.shift();
                        var index = value.indexOf(child);
                        if (child.children && child.children.length) {
                            children.push.apply(children, child.children);
                        }
                        else if (!~index && child.value !== 'undefined') {
                            value.push(child);
                        }
                    }
                }
                else {
                    // 只要父节点选择了,子节点就不需要了,全部去掉勾选.  withChildren时相反
                    while (children.length) {
                        var child = children.shift();
                        var index = value.indexOf(child);
                        if (~index) {
                            value.splice(index, 1);
                        }
                        if (withChildren || cascade) {
                            value.push(child);
                        }
                        if (child.children && child.children.length) {
                            children.push.apply(children, child.children);
                        }
                    }
                    var toCheck = item;
                    while (true) {
                        var parent_1 = amisCore.getTreeParent(props.options, toCheck);
                        // 判断 parent 节点是否已经勾选，避免重复值
                        if ((parent_1 === null || parent_1 === void 0 ? void 0 : parent_1.value) && !~value.indexOf(parent_1)) {
                            // 如果所有孩子节点都勾选了，应该自动勾选父级。
                            if (parent_1.children.every(function (child) { return ~value.indexOf(child); })) {
                                if (!cascade && !withChildren) {
                                    parent_1.children.forEach(function (child) {
                                        var index = value.indexOf(child);
                                        if (~index) {
                                            value.splice(index, 1);
                                        }
                                    });
                                }
                                value.push(parent_1);
                                toCheck = parent_1;
                                continue;
                            }
                        }
                        break;
                    }
                }
            }
        }
        else {
            ~idx && value.splice(idx, 1);
            if (autoCheckChildren) {
                if (cascade || withChildren || onlyChildren) {
                    var children = item.children ? item.children.concat([]) : [];
                    while (children.length) {
                        var child = children.shift();
                        var index = value.indexOf(child);
                        if (~index) {
                            value.splice(index, 1);
                        }
                        if (child.children && child.children.length) {
                            children.push.apply(children, child.children);
                        }
                    }
                }
            }
        }
        this.setState({
            value: value
        }, function () { return _this.fireChange(value); });
    };
    TreeSelector.prototype.fireChange = function (value) {
        var _a = this.props, joinValues = _a.joinValues, extractValue = _a.extractValue, valueField = _a.valueField, delimiter = _a.delimiter, onChange = _a.onChange, enableNodePath = _a.enableNodePath;
        onChange(enableNodePath
            ? this.transform2NodePath(value)
            : joinValues
                ? value.map(function (item) { return item[valueField]; }).join(delimiter)
                : extractValue
                    ? value.map(function (item) { return item[valueField]; })
                    : value);
    };
    TreeSelector.prototype.handleAdd = function (parent) {
        var _this = this;
        if (parent === void 0) { parent = null; }
        var _a = this.props, bultinCUD = _a.bultinCUD, onAdd = _a.onAdd, options = _a.options;
        if (!bultinCUD) {
            var idxes = amisCore.findTreeIndex(options, function (item) { return item === parent; }) || [];
            return onAdd && onAdd(idxes.concat(0));
        }
        else {
            this.setState({
                isEditing: false,
                isAdding: true,
                addingParent: parent
            }, function () {
                var e_1, _a;
                if (!parent) {
                    return;
                }
                var result = [];
                try {
                    for (var _b = tslib.__values(_this.state.flattenedOptions), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var option = _c.value;
                        result.push(option);
                        if (option === parent) {
                            result.push(tslib.__assign(tslib.__assign({}, option), { isAdding: true }));
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                _this.setState({ flattenedOptions: result });
            });
        }
    };
    TreeSelector.prototype.handleEdit = function (item) {
        var _a = this.props, bultinCUD = _a.bultinCUD, onEdit = _a.onEdit, labelField = _a.labelField; _a.options;
        if (!bultinCUD) {
            onEdit === null || onEdit === void 0 ? void 0 : onEdit(item);
        }
        else {
            this.setState({
                isEditing: true,
                isAdding: false,
                editingItem: item,
                inputValue: item[labelField]
            });
        }
    };
    TreeSelector.prototype.handleRemove = function (item) {
        var onDelete = this.props.onDelete;
        onDelete && onDelete(item);
    };
    TreeSelector.prototype.handleInputChange = function (e) {
        this.setState({
            inputValue: e.currentTarget.value
        });
    };
    TreeSelector.prototype.handleConfirm = function () {
        var _a = this.state, value = _a.inputValue, isAdding = _a.isAdding, addingParent = _a.addingParent, editingItem = _a.editingItem, isEditing = _a.isEditing;
        if (!value) {
            return;
        }
        var _b = this.props, labelField = _b.labelField, onAdd = _b.onAdd, options = _b.options, onEdit = _b.onEdit;
        this.setState({
            inputValue: '',
            isAdding: false,
            isEditing: false
        }, function () {
            var _a, _b;
            if (isAdding && onAdd) {
                var idxes = (addingParent &&
                    amisCore.findTreeIndex(options, function (item) { return item === addingParent; })) ||
                    [];
                onAdd(idxes.concat(0), (_a = {}, _a[labelField] = value, _a), true);
            }
            else if (isEditing && onEdit) {
                onEdit(tslib.__assign(tslib.__assign({}, editingItem), (_b = {}, _b[labelField] = value, _b)), editingItem, true);
            }
        });
    };
    TreeSelector.prototype.handleCancel = function () {
        var flattenedOptions = this.state.flattenedOptions;
        var flattenedOptionsWithoutAdding = flattenedOptions.filter(function (item) { return !item.isAdding; });
        this.setState({
            inputValue: '',
            isAdding: false,
            isEditing: false,
            flattenedOptions: flattenedOptionsWithoutAdding
        });
    };
    TreeSelector.prototype.renderInput = function (prfix) {
        if (prfix === void 0) { prfix = null; }
        var _a = this.props, cx = _a.classnames, __ = _a.translate;
        var inputValue = this.state.inputValue;
        return (React__default["default"].createElement("div", { className: cx('Tree-itemLabel') },
            React__default["default"].createElement("div", { className: cx('Tree-itemInput') },
                prfix,
                React__default["default"].createElement("input", { onChange: this.handleInputChange, value: inputValue, placeholder: __('placeholder.enter') }),
                React__default["default"].createElement("a", { "data-tooltip": __('cancel'), onClick: this.handleCancel },
                    React__default["default"].createElement(icons.Icon, { icon: "close", className: "icon" })),
                React__default["default"].createElement("a", { "data-tooltip": __('confirm'), onClick: this.handleConfirm },
                    React__default["default"].createElement(icons.Icon, { icon: "check", className: "icon" })))));
    };
    TreeSelector.prototype.getOffsetPosition = function (element) {
        var left = 0;
        var top = 0;
        while (element.offsetParent) {
            left += element.offsetLeft;
            top += element.offsetTop;
            element = element.offsetParent;
        }
        return { left: left, top: top };
    };
    TreeSelector.prototype.getDropInfo = function (e, node) {
        var _a;
        var rect = e.currentTarget.getBoundingClientRect();
        var dragNode = this.dragNode;
        var deltaX = Math.min(50, rect.width * 0.3);
        var gap = ((_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.length) ? 0 : 16;
        // 计算相对位置
        var offset = this.getOffsetPosition(this.root.current);
        var targetOffset = this.getOffsetPosition(e.currentTarget);
        var left = targetOffset.left - offset.left;
        var top = targetOffset.top - offset.top;
        var clientX = e.clientX, clientY = e.clientY;
        var position = clientY >= rect.top + rect.height / 2 ? 'bottom' : 'top';
        var indicator;
        if (position === 'bottom' && clientX >= this.startPoint.x + deltaX) {
            position = 'self';
            indicator = {
                top: top,
                left: left,
                width: rect.width,
                height: rect.height
            };
        }
        else {
            indicator = {
                top: position === 'bottom' ? top + rect.height : top,
                left: left + gap,
                width: rect.width - gap
            };
        }
        return {
            node: node,
            dragNode: dragNode,
            position: position,
            indicator: indicator
        };
    };
    TreeSelector.prototype.updateDropIndicator = function (e, node) {
        // const gap = node?.children?.length ? 0 : 16;
        this.dropInfo = this.getDropInfo(e, node);
        var _a = this.dropInfo, dragNode = _a.dragNode, indicator = _a.indicator;
        if (node === dragNode) {
            this.setState({ dropIndicator: undefined });
            return;
        }
        this.setState({
            dropIndicator: indicator
        });
    };
    TreeSelector.prototype.onDragStart = function (node) {
        var _this = this;
        var draggable = this.props.draggable;
        return function (e) {
            var _a;
            if (draggable) {
                e.dataTransfer.effectAllowed = 'copyMove';
                _this.dragNode = node;
                _this.dropInfo = null;
                _this.startPoint = {
                    x: e.clientX,
                    y: e.clientY
                };
                if ((_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.length) {
                    _this.unfolded.set(node, false);
                    _this.flattenOptions();
                    _this.forceUpdate();
                }
            }
            else {
                _this.dragNode = null;
                _this.dropInfo = null;
            }
            e.stopPropagation();
        };
    };
    TreeSelector.prototype.onDragOver = function (node) {
        var _this = this;
        return function (e) {
            if (!_this.dragNode) {
                return;
            }
            _this.updateDropIndicator(e, node);
            e.preventDefault();
        };
    };
    TreeSelector.prototype.onDragEnd = function (dragNode) {
        var _this = this;
        return function (e) {
            var _a, _b, _c;
            _this.setState({
                dropIndicator: undefined
            });
            var node = (_a = _this.dropInfo) === null || _a === void 0 ? void 0 : _a.node;
            if (!_this.dropInfo || !node || dragNode === node) {
                return;
            }
            (_c = (_b = _this.props).onMove) === null || _c === void 0 ? void 0 : _c.call(_b, _this.dropInfo);
            _this.dragNode = null;
            _this.dropInfo = null;
            e.preventDefault();
        };
    };
    /**
     * 将树形接口转换为平铺结构，以支持虚拟列表
     * TODO: this.unfolded => reaction 更加合理
     */
    TreeSelector.prototype.flattenOptions = function (props, initial) {
        var _this = this;
        var flattenedOptions = [];
        amisCore.eachTree((props === null || props === void 0 ? void 0 : props.options) || this.props.options, function (item, index, level, paths) {
            var parent = paths[paths.length - 2];
            if (!amisCore.isVisible(item)) {
                return;
            }
            if (paths.length === 1) {
                // 父节点
                flattenedOptions.push(item);
            }
            else if (_this.isUnfolded(parent)) {
                _this.relations.set(item, parent);
                // 父节点是展开的状态
                item.level = level;
                flattenedOptions.push(item);
            }
        });
        if (initial) {
            // 初始化
            this.state = tslib.__assign(tslib.__assign({}, this.state), { flattenedOptions: flattenedOptions });
        }
        else {
            this.setState({
                flattenedOptions: flattenedOptions
            });
        }
    };
    /**
     * 判断父元素是否勾选
     * TODO: 递归可能需要优化
     */
    TreeSelector.prototype.isParentChecked = function (item) {
        if (!item || !this.relations.get(item)) {
            return false;
        }
        var itemParent = this.relations.get(item);
        var value = this.state.value;
        var checked = !!~value.indexOf(itemParent);
        return checked || this.isParentChecked(itemParent);
    };
    /**
     * 判断 子元素 是否全部选中
     */
    TreeSelector.prototype.isItemChildrenChecked = function (item) {
        var _this = this;
        if (!item || !item.children) {
            return true;
        }
        return !item.children.some(function (child) { return !_this.isItemChecked(child); });
    };
    /**
     * 判断子元素 部分勾选
     */
    TreeSelector.prototype.isItemChildrenPartialChecked = function (item, checked) {
        var e_2, _a;
        if (!item || !item.children || checked) {
            return false;
        }
        var checkedLength = 0;
        var partialChildrenLength = 0;
        try {
            for (var _b = tslib.__values(item.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                if (this.isItemChecked(child)) {
                    checkedLength++;
                }
                else if (this.isItemChildrenPartialChecked(child, false)) {
                    partialChildrenLength++;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return checkedLength !== 0 || partialChildrenLength !== 0;
    };
    /**
     * 判断元素是否选中：checked
     */
    TreeSelector.prototype.isItemChecked = function (item) {
        var _a;
        if (!item) {
            return false;
        }
        var _b = this.props, autoCheckChildren = _b.autoCheckChildren, onlyChildren = _b.onlyChildren, multiple = _b.multiple, withChildren = _b.withChildren, cascade = _b.cascade;
        var value = this.state.value;
        var checked = !!~value.indexOf(item);
        if (checked) {
            return true;
        }
        if ((_a = item.children) === null || _a === void 0 ? void 0 : _a.length) {
            if (onlyChildren &&
                autoCheckChildren &&
                this.isItemChildrenChecked(item) // TODO: 优化这个逻辑
            ) {
                // 当前元素没有在 value 中，但是子组件全部勾选了
                return true;
            }
        }
        var itemParent = this.relations.get(item);
        if (itemParent && multiple && autoCheckChildren) {
            // 当前节点为子节点
            if (withChildren) {
                return false;
            }
            if (cascade) {
                return false;
            }
            return this.isParentChecked(item);
        }
        // 判断父组件是否勾选
        return false;
    };
    /**
     * item 是否 disabled 状态
     * props.disabled === true return;
     *
     */
    TreeSelector.prototype.isItemDisabled = function (item, checked) {
        var _a = this.props, disabledField = _a.disabledField, disabled = _a.disabled, autoCheckChildren = _a.autoCheckChildren, valueField = _a.valueField, multiple = _a.multiple, maxLength = _a.maxLength, minLength = _a.minLength, cascade = _a.cascade, onlyChildren = _a.onlyChildren;
        var value = this.state.value;
        var selfDisabled = item[disabledField];
        var nodeDisabled = !!disabled ||
            selfDisabled ||
            (multiple && !autoCheckChildren && !item[valueField]);
        if (nodeDisabled) {
            return true;
        }
        if ((maxLength && !checked && value.length >= maxLength) ||
            (minLength && checked && value.length <= minLength)) {
            return true;
        }
        var itemParent = this.relations.get(item);
        if (autoCheckChildren &&
            multiple &&
            checked &&
            itemParent &&
            this.isItemChecked(itemParent)) {
            // 子节点
            if (onlyChildren) {
                return false;
            }
            return !cascade;
        }
        return false;
    };
    TreeSelector.prototype.renderItem = function (_a) {
        var _this = this;
        var index = _a.index, style = _a.style;
        var _b = this.props, itemClassName = _b.itemClassName, showIcon = _b.showIcon, showRadio = _b.showRadio, multiple = _b.multiple, labelField = _b.labelField, iconField = _b.iconField, cascade = _b.cascade, cx = _b.classnames, highlightTxt = _b.highlightTxt, creatable = _b.creatable, editable = _b.editable, removable = _b.removable, createTip = _b.createTip, editTip = _b.editTip, removeTip = _b.removeTip, __ = _b.translate, itemRender = _b.itemRender, draggable = _b.draggable, loadingConfig = _b.loadingConfig, enableDefaultIcon = _b.enableDefaultIcon, valueField = _b.valueField;
        var item = this.state.flattenedOptions[index];
        if (!item) {
            return null;
        }
        var _c = this.state, isAdding = _c.isAdding, editingItem = _c.editingItem, isEditing = _c.isEditing;
        var checked = this.isItemChecked(item);
        var disabled = this.isItemDisabled(item, checked);
        var partial = this.isItemChildrenPartialChecked(item, checked);
        var checkedInValue = !!~this.state.value.indexOf(item);
        var checkbox = multiple ? (React__default["default"].createElement(Checkbox["default"], { size: "sm", disabled: disabled, checked: checked || partial, partial: partial, onChange: this.handleCheck.bind(this, item, !checked) })) : showRadio ? (React__default["default"].createElement(Checkbox["default"], { size: "sm", disabled: disabled, checked: checked, onChange: this.handleSelect.bind(this, item) })) : null;
        var isLeaf = (!item.children || !item.children.length) && !item.placeholder;
        var iconValue = item[iconField] ||
            (enableDefaultIcon !== false
                ? item.children
                    ? 'folder'
                    : 'file'
                : false);
        var level = item.level ? item.level - 1 : 0;
        var body = null;
        if (isEditing && editingItem === item) {
            body = this.renderInput(checkbox);
        }
        else if (item.isAdding) {
            body = this.renderInput(checkbox);
        }
        else {
            body = (React__default["default"].createElement("div", { className: cx('Tree-itemLabel', {
                    'is-children-checked': multiple &&
                        !cascade &&
                        this.isItemChildrenChecked(item) &&
                        !disabled,
                    'is-checked': checkedInValue,
                    'is-disabled': disabled
                }), draggable: draggable, onDragStart: this.onDragStart(item), onDragOver: this.onDragOver(item), onDragEnd: this.onDragEnd(item) },
                draggable && (React__default["default"].createElement("a", { className: cx('Tree-itemDrager drag-bar') },
                    React__default["default"].createElement(icons.Icon, { icon: "drag-bar", className: "icon" }))),
                item.loading ? (React__default["default"].createElement(Spinner["default"], { size: "sm", show: true, icon: "reload", spinnerClassName: cx('Tree-spinner'), loadingConfig: loadingConfig })) : !isLeaf || (item.defer && !item.loaded) ? (React__default["default"].createElement("div", { onClick: function () { return _this.toggleUnfolded(item); }, className: cx('Tree-itemArrow', {
                        'is-folded': !this.isUnfolded(item)
                    }) },
                    React__default["default"].createElement(icons.Icon, { icon: "down-arrow-bold", className: "icon" }))) : (React__default["default"].createElement("span", { className: cx('Tree-itemArrowPlaceholder') })),
                checkbox,
                React__default["default"].createElement("div", { className: cx('Tree-itemLabel-item') },
                    showIcon ? (React__default["default"].createElement("i", { className: cx("Tree-itemIcon ".concat(item.children ? 'Tree-folderIcon' : 'Tree-leafIcon')), onClick: function () {
                            return !disabled &&
                                (multiple
                                    ? _this.handleCheck(item, !checked)
                                    : _this.handleSelect(item));
                        } }, iconValue ? (icons.getIcon(iconValue) ? (React__default["default"].createElement(icons.Icon, { icon: iconValue, className: "icon" })) : React__default["default"].isValidElement(iconValue) ? (iconValue) : (React__default["default"].createElement("i", { className: iconValue }))) : null)) : null,
                    React__default["default"].createElement("span", { className: cx('Tree-itemText'), onClick: function () {
                            return !disabled &&
                                (multiple
                                    ? _this.handleCheck(item, !checked)
                                    : _this.handleSelect(item));
                        }, title: item[labelField] }, itemRender
                        ? itemRender(item, {
                            index: index,
                            multiple: multiple,
                            checked: checked,
                            onChange: function () { return _this.handleCheck(item, !checked); },
                            disabled: disabled || item.disabled
                        })
                        : highlightTxt
                            ? amisCore.highlight("".concat(item[labelField]), highlightTxt)
                            : "".concat(item[labelField])),
                    !disabled &&
                        !isAdding &&
                        !isEditing &&
                        !(item.defer && !item.loaded) ? (React__default["default"].createElement("div", { className: cx('Tree-item-icons') },
                        creatable && amisCore.hasAbility(item, 'creatable') ? (React__default["default"].createElement("a", { onClick: this.handleAdd.bind(this, item), "data-tooltip": __(createTip), "data-position": "left" },
                            React__default["default"].createElement(icons.Icon, { icon: "plus", className: "icon" }))) : null,
                        removable && amisCore.hasAbility(item, 'removable') ? (React__default["default"].createElement("a", { onClick: this.handleRemove.bind(this, item), "data-tooltip": __(removeTip), "data-position": "left" },
                            React__default["default"].createElement(icons.Icon, { icon: "minus", className: "icon" }))) : null,
                        editable && amisCore.hasAbility(item, 'editable') ? (React__default["default"].createElement("a", { onClick: this.handleEdit.bind(this, item), "data-tooltip": __(editTip), "data-position": "left" },
                            React__default["default"].createElement(icons.Icon, { icon: "new-edit", className: "icon" }))) : null)) : null)));
        }
        return (React__default["default"].createElement("li", { key: item[valueField], className: cx("Tree-item ".concat(itemClassName || ''), {
                'Tree-item--isLeaf': isLeaf,
                'is-child': this.relations.get(item)
            }), style: tslib.__assign(tslib.__assign({}, style), { left: "calc(".concat(level, " * var(--Tree-indent))"), width: "calc(100% - ".concat(level, " * var(--Tree-indent))") }) }, body));
    };
    TreeSelector.prototype.isEmptyOrNotExist = function (obj) {
        return obj === '' || obj === undefined || obj === null;
    };
    TreeSelector.prototype.getAvailableOptions = function () {
        var _this = this;
        var _a = this.props, options = _a.options, onlyChildren = _a.onlyChildren, valueField = _a.valueField;
        var flattendOptions = amisCore.flattenTree(options, function (item) {
            return onlyChildren
                ? item.children
                    ? null
                    : item
                : _this.isEmptyOrNotExist(item[valueField || 'value'])
                    ? null
                    : item;
        }).filter(function (a) { return a && !a.disabled; });
        return flattendOptions;
    };
    TreeSelector.prototype.handleCheckAll = function (availableOptions, checkedAll) {
        var _this = this;
        this.setState({
            value: checkedAll ? [] : availableOptions
        }, function () { return _this.fireChange(checkedAll ? [] : availableOptions); });
    };
    TreeSelector.prototype.renderCheckAll = function () {
        var _this = this;
        var _a = this.props, multiple = _a.multiple, checkAll = _a.checkAll, checkAllLabel = _a.checkAllLabel, cx = _a.classnames, __ = _a.translate, disabled = _a.disabled;
        if (!multiple || !checkAll) {
            return null;
        }
        var availableOptions = this.getAvailableOptions();
        var checkedAll = availableOptions.every(function (option) {
            return _this.isItemChecked(option);
        });
        var checkedPartial = availableOptions.some(function (option) {
            return _this.isItemChecked(option);
        });
        return (React__default["default"].createElement("div", { className: cx('Tree-itemLabel'), onClick: function () { return _this.handleCheckAll(availableOptions, checkedAll); } },
            React__default["default"].createElement(Checkbox["default"], { size: "sm", disabled: disabled, checked: checkedPartial, partial: checkedPartial && !checkedAll }),
            React__default["default"].createElement("div", { className: cx('Tree-itemLabel-item') },
                React__default["default"].createElement("span", { className: cx('Tree-itemText') }, __(checkAllLabel)))));
    };
    TreeSelector.prototype.renderList = function (list, value) {
        var _this = this;
        var _a = this.props, virtualThreshold = _a.virtualThreshold, _b = _a.itemHeight, itemHeight = _b === void 0 ? 32 : _b;
        if (virtualThreshold && list.length > virtualThreshold) {
            return (React__default["default"].createElement(index["default"], { height: list.length > 8 ? 266 : list.length * itemHeight, itemCount: list.length, prefix: this.renderCheckAll(), itemSize: itemHeight, 
                //! hack: 让 VirtualList 重新渲染
                renderItem: this.renderItem.bind(this) }));
        }
        return (React__default["default"].createElement(React__default["default"].Fragment, null,
            this.renderCheckAll(),
            list.map(function (item, index) { return _this.renderItem({ index: index }); })));
    };
    TreeSelector.prototype.render = function () {
        var _a = this.props, className = _a.className, placeholder = _a.placeholder, hideRoot = _a.hideRoot, rootLabel = _a.rootLabel, showOutline = _a.showOutline, showIcon = _a.showIcon, cx = _a.classnames, creatable = _a.creatable, rootCreatable = _a.rootCreatable, rootCreateTip = _a.rootCreateTip, disabled = _a.disabled, draggable = _a.draggable, __ = _a.translate;
        var _b = this.state, value = _b.value, isAdding = _b.isAdding, addingParent = _b.addingParent, isEditing = _b.isEditing, dropIndicator = _b.dropIndicator, flattenedOptions = _b.flattenedOptions;
        var addBtn = null;
        if (creatable && rootCreatable !== false && hideRoot) {
            addBtn = (React__default["default"].createElement("a", { className: cx('Tree-addTopBtn', {
                    'is-disabled': isAdding || isEditing
                }), onClick: this.handleAdd.bind(this, null) },
                React__default["default"].createElement(icons.Icon, { icon: "plus", className: "icon" }),
                React__default["default"].createElement("span", null, __(rootCreateTip))));
        }
        return (React__default["default"].createElement("div", { className: cx("Tree ".concat(className || ''), {
                'Tree--outline': showOutline,
                'is-disabled': disabled,
                'is-draggable': draggable
            }), ref: this.root },
            (flattenedOptions && flattenedOptions.length) ||
                addBtn ||
                hideRoot === false ? (React__default["default"].createElement("ul", { className: cx('Tree-list') }, hideRoot ? (React__default["default"].createElement(React__default["default"].Fragment, null,
                addBtn,
                isAdding && !addingParent ? (React__default["default"].createElement("li", { className: cx('Tree-item') }, this.renderInput())) : null,
                this.renderList(flattenedOptions, value))) : (React__default["default"].createElement("li", { className: cx('Tree-rootItem', {
                    'is-checked': !value || !value.length
                }) },
                React__default["default"].createElement("div", { className: cx('Tree-itemLabel') },
                    React__default["default"].createElement("span", { className: cx('Tree-itemText'), onClick: this.clearSelect },
                        showIcon ? (React__default["default"].createElement("i", { className: cx('Tree-itemIcon Tree-rootIcon') },
                            React__default["default"].createElement(icons.Icon, { icon: "home", className: "icon" }))) : null,
                        rootLabel),
                    !disabled &&
                        creatable &&
                        rootCreatable !== false &&
                        !isAdding &&
                        !isEditing ? (React__default["default"].createElement("div", { className: cx('Tree-item-icons') }, creatable ? (React__default["default"].createElement("a", { onClick: this.handleAdd.bind(this, null), "data-tooltip": rootCreateTip, "data-position": "left" },
                        React__default["default"].createElement(icons.Icon, { icon: "plus", className: "icon" }))) : null)) : null),
                React__default["default"].createElement("ul", { className: cx('Tree-sublist') },
                    isAdding && !addingParent ? (React__default["default"].createElement("li", { className: cx('Tree-item') }, this.renderInput())) : null,
                    this.renderList(flattenedOptions, value)))))) : (React__default["default"].createElement("div", { className: cx('Tree-placeholder') }, placeholder)),
            dropIndicator && (React__default["default"].createElement("div", { className: cx('Tree-dropIndicator', {
                    'Tree-dropIndicator--hover': !!dropIndicator.height
                }), style: dropIndicator }))));
    };
    TreeSelector.defaultProps = {
        showIcon: true,
        showOutline: false,
        initiallyOpen: true,
        unfoldedLevel: 1,
        showRadio: false,
        multiple: false,
        disabled: false,
        withChildren: false,
        onlyChildren: false,
        labelField: 'label',
        valueField: 'value',
        iconField: 'icon',
        unfoldedField: 'unfolded',
        foldedField: 'foled',
        disabledField: 'disabled',
        joinValues: true,
        extractValue: false,
        delimiter: ',',
        hideRoot: true,
        rootLabel: 'Tree.root',
        rootValue: 0,
        autoCheckChildren: true,
        cascade: false,
        selfDisabledAffectChildren: true,
        rootCreateTip: 'Tree.addRoot',
        createTip: 'Tree.addChild',
        editTip: 'Tree.editNode',
        removeTip: 'Tree.removeNode',
        enableNodePath: false,
        pathSeparator: '/',
        nodePath: [],
        virtualThreshold: 100,
        itemHeight: 32,
        enableDefaultIcon: true
    };
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "toggleUnfolded", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "clearSelect", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleSelect", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Boolean]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleCheck", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleAdd", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleEdit", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleRemove", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleInputChange", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleConfirm", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleCancel", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Object]),
        tslib.__metadata("design:returntype", Object)
    ], TreeSelector.prototype, "getDropInfo", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "updateDropIndicator", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "onDragStart", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "onDragOver", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "onDragEnd", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "renderItem", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Array, Boolean]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleCheckAll", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Array]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "renderList", null);
    return TreeSelector;
}(React__default["default"].Component));
var Tree = amisCore.themeable(amisCore.localeable(TreeSelector));

exports.TreeSelector = TreeSelector;
exports["default"] = Tree;
