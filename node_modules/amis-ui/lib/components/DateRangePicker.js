/**
 * amis-ui v2.9.0
 * Copyright 2018-2023 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var moment = require('moment');
var omit = require('lodash/omit');
var kebabCase = require('lodash/kebabCase');
var ReactDOM = require('react-dom');
var icons = require('./icons.js');
var amisCore = require('amis-core');
var Calendar = require('./calendar/Calendar.js');
var PopUp = require('./PopUp.js');
var CalendarMobile = require('./CalendarMobile.js');
var Input = require('./Input.js');
var Button = require('./Button.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var moment__default = /*#__PURE__*/_interopDefaultLegacy(moment);
var omit__default = /*#__PURE__*/_interopDefaultLegacy(omit);
var kebabCase__default = /*#__PURE__*/_interopDefaultLegacy(kebabCase);

/**
 * @file DateRangePicker
 * @description 自定义日期范围时间选择器组件
 * @author fex
 */
var availableRanges = {
    'today': {
        label: 'Date.today',
        startDate: function (now) {
            return now.startOf('day');
        },
        endDate: function (now) {
            return now;
        }
    },
    'yesterday': {
        label: 'Date.yesterday',
        startDate: function (now) {
            return now.add(-1, 'days').startOf('day');
        },
        endDate: function (now) {
            return now.add(-1, 'days').endOf('day');
        }
    },
    'tomorrow': {
        label: 'Date.tomorrow',
        startDate: function (now) {
            return now.add(1, 'days').startOf('day');
        },
        endDate: function (now) {
            return now.add(1, 'days').endOf('day');
        }
    },
    // 兼容一下错误的用法
    '1daysago': {
        label: 'DateRange.1daysago',
        startDate: function (now) {
            return now.add(-1, 'days');
        },
        endDate: function (now) {
            return now;
        }
    },
    '1dayago': {
        label: 'DateRange.1daysago',
        startDate: function (now) {
            return now.add(-1, 'days');
        },
        endDate: function (now) {
            return now;
        }
    },
    '7daysago': {
        label: 'DateRange.7daysago',
        startDate: function (now) {
            return now.add(-7, 'days').startOf('day');
        },
        endDate: function (now) {
            return now.add(-1, 'days').endOf('day');
        }
    },
    '30daysago': {
        label: 'DateRange.30daysago',
        startDate: function (now) {
            return now.add(-30, 'days').startOf('day');
        },
        endDate: function (now) {
            return now.add(-1, 'days').endOf('day');
        }
    },
    '90daysago': {
        label: 'DateRange.90daysago',
        startDate: function (now) {
            return now.add(-90, 'days').startOf('day');
        },
        endDate: function (now) {
            return now.add(-1, 'days').endOf('day');
        }
    },
    'prevweek': {
        label: 'DateRange.lastWeek',
        startDate: function (now) {
            return now.startOf('week').add(-1, 'weeks');
        },
        endDate: function (now) {
            return now.startOf('week').add(-1, 'days').endOf('day');
        }
    },
    'thisweek': {
        label: 'DateRange.thisWeek',
        startDate: function (now) {
            return now.startOf('week');
        },
        endDate: function (now) {
            return now.endOf('week');
        }
    },
    'thismonth': {
        label: 'DateRange.thisMonth',
        startDate: function (now) {
            return now.startOf('month');
        },
        endDate: function (now) {
            return now.endOf('month');
        }
    },
    'thisquarter': {
        label: 'DateRange.thisQuarter',
        startDate: function (now) {
            return now.startOf('quarter');
        },
        endDate: function (now) {
            return now.endOf('quarter');
        }
    },
    'prevmonth': {
        label: 'DateRange.lastMonth',
        startDate: function (now) {
            return now.startOf('month').add(-1, 'month');
        },
        endDate: function (now) {
            return now.startOf('month').add(-1, 'day').endOf('day');
        }
    },
    'prevquarter': {
        label: 'DateRange.lastQuarter',
        startDate: function (now) {
            return now.startOf('quarter').add(-1, 'quarter');
        },
        endDate: function (now) {
            return now.startOf('quarter').add(-1, 'day').endOf('day');
        }
    },
    'thisyear': {
        label: 'DateRange.thisYear',
        startDate: function (now) {
            return now.startOf('year');
        },
        endDate: function (now) {
            return now.endOf('year');
        }
    },
    // 兼容一下之前的用法 'lastYear'
    'prevyear': {
        label: 'DateRange.lastYear',
        startDate: function (now) {
            return now.startOf('year').add(-1, 'year');
        },
        endDate: function (now) {
            return now.endOf('year').add(-1, 'year').endOf('day');
        }
    },
    'lastYear': {
        label: 'DateRange.lastYear',
        startDate: function (now) {
            return now.startOf('year').add(-1, 'year');
        },
        endDate: function (now) {
            return now.endOf('year').add(-1, 'year').endOf('day');
        }
    }
};
var advancedRanges = [
    {
        regexp: /^(\d+)hoursago$/,
        resolve: function (__, _, hours) {
            return {
                label: __('DateRange.hoursago', { hours: hours }),
                startDate: function (now) {
                    return now.add(-hours, 'hours').startOf('hour');
                },
                endDate: function (now) {
                    return now.add(-1, 'hours').endOf('hours');
                }
            };
        }
    },
    {
        regexp: /^(\d+)hourslater$/,
        resolve: function (__, _, hours) {
            return {
                label: __('DateRange.hourslater', { hours: hours }),
                startDate: function (now) {
                    return now.startOf('hour');
                },
                endDate: function (now) {
                    return now.add(hours, 'hours').endOf('hour');
                }
            };
        }
    },
    {
        regexp: /^(\d+)daysago$/,
        resolve: function (__, _, days) {
            return {
                label: __('DateRange.daysago', { days: days }),
                startDate: function (now) {
                    return now.add(-days, 'days').startOf('day');
                },
                endDate: function (now) {
                    return now.add(-1, 'days').endOf('day');
                }
            };
        }
    },
    {
        regexp: /^(\d+)dayslater$/,
        resolve: function (__, _, days) {
            return {
                label: __('DateRange.dayslater', { days: days }),
                startDate: function (now) {
                    return now.startOf('day');
                },
                endDate: function (now) {
                    return now.add(days, 'days').endOf('day');
                }
            };
        }
    },
    {
        regexp: /^(\d+)weeksago$/,
        resolve: function (__, _, weeks) {
            return {
                label: __('DateRange.weeksago', { weeks: weeks }),
                startDate: function (now) {
                    return now.startOf('week').add(-weeks, 'weeks');
                },
                endDate: function (now) {
                    return now.startOf('week').add(-1, 'days').endOf('day');
                }
            };
        }
    },
    {
        regexp: /^(\d+)weekslater$/,
        resolve: function (__, _, weeks) {
            return {
                label: __('DateRange.weekslater', { weeks: weeks }),
                startDate: function (now) {
                    return now.startOf('week');
                },
                endDate: function (now) {
                    return now.startOf('week').add(weeks, 'weeks').endOf('day');
                }
            };
        }
    },
    {
        regexp: /^(\d+)monthsago$/,
        resolve: function (__, _, months) {
            return {
                label: __('DateRange.monthsago', { months: months }),
                startDate: function (now) {
                    return now.startOf('months').add(-months, 'months');
                },
                endDate: function (now) {
                    return now.startOf('month').add(-1, 'days').endOf('day');
                }
            };
        }
    },
    {
        regexp: /^(\d+)monthslater$/,
        resolve: function (__, _, months) {
            return {
                label: __('DateRange.monthslater', { months: months }),
                startDate: function (now) {
                    return now.startOf('month');
                },
                endDate: function (now) {
                    return now.startOf('month').add(months, 'months').endOf('day');
                }
            };
        }
    },
    {
        regexp: /^(\d+)quartersago$/,
        resolve: function (__, _, quarters) {
            return {
                label: __('DateRange.quartersago', { quarters: quarters }),
                startDate: function (now) {
                    return now.startOf('quarters').add(-quarters, 'quarters');
                },
                endDate: function (now) {
                    return now.startOf('quarter').add(-1, 'days').endOf('day');
                }
            };
        }
    },
    {
        regexp: /^(\d+)quarterslater$/,
        resolve: function (__, _, quarters) {
            return {
                label: __('DateRange.quarterslater', { quarters: quarters }),
                startDate: function (now) {
                    return now.startOf('quarter');
                },
                endDate: function (now) {
                    return now.startOf('quarter').add(quarters, 'quarters').endOf('day');
                }
            };
        }
    },
    {
        regexp: /^(\d+)yearsago$/,
        resolve: function (__, _, years) {
            return {
                label: __('DateRange.yearsago', { years: years }),
                startDate: function (now) {
                    return now.startOf('years').add(-years, 'years');
                },
                endDate: function (now) {
                    return now.startOf('year').add(-1, 'days').endOf('day');
                }
            };
        }
    },
    {
        regexp: /^(\d+)yearslater$/,
        resolve: function (__, _, years) {
            return {
                label: __('DateRange.yearslater', { years: years }),
                startDate: function (now) {
                    return now.startOf('year');
                },
                endDate: function (now) {
                    return now.startOf('year').add(years, 'years').endOf('day');
                }
            };
        }
    }
];
var DateRangePicker = /** @class */ (function (_super) {
    tslib.__extends(DateRangePicker, _super);
    function DateRangePicker(props) {
        var _this = _super.call(this, props) || this;
        // 是否是第一次点击，如果是第一次点击就可以点任意地址
        _this.isFirstClick = true;
        _this.nextMonth = moment__default["default"]().add(1, 'months').startOf('day');
        _this.currentMonth = moment__default["default"]().startOf('day');
        _this.startInputRef = React__default["default"].createRef();
        _this.endInputRef = React__default["default"].createRef();
        _this.separatorRef = React__default["default"].createRef();
        _this.calendarRef = React__default["default"].createRef();
        _this.open = _this.open.bind(_this);
        _this.openStart = _this.openStart.bind(_this);
        _this.openEnd = _this.openEnd.bind(_this);
        _this.close = _this.close.bind(_this);
        _this.startInputChange = _this.startInputChange.bind(_this);
        _this.endInputChange = _this.endInputChange.bind(_this);
        _this.handleDateChange = _this.handleDateChange.bind(_this);
        _this.handleStartDateChange = _this.handleStartDateChange.bind(_this);
        _this.handelEndDateChange = _this.handelEndDateChange.bind(_this);
        _this.handleTimeStartChange = _this.handleTimeStartChange.bind(_this);
        _this.handleTimeEndChange = _this.handleTimeEndChange.bind(_this);
        _this.handleFocus = _this.handleFocus.bind(_this);
        _this.handleBlur = _this.handleBlur.bind(_this);
        _this.checkStartIsValidDate = _this.checkStartIsValidDate.bind(_this);
        _this.checkEndIsValidDate = _this.checkEndIsValidDate.bind(_this);
        _this.confirm = _this.confirm.bind(_this);
        _this.clearValue = _this.clearValue.bind(_this);
        _this.dom = React__default["default"].createRef();
        _this.handleClick = _this.handleClick.bind(_this);
        _this.handleKeyPress = _this.handleKeyPress.bind(_this);
        _this.handlePopOverClick = _this.handlePopOverClick.bind(_this);
        _this.renderDay = _this.renderDay.bind(_this);
        _this.renderMonth = _this.renderMonth.bind(_this);
        _this.renderQuarter = _this.renderQuarter.bind(_this);
        _this.renderYear = _this.renderYear.bind(_this);
        _this.handleMobileChange = _this.handleMobileChange.bind(_this);
        _this.handleOutClick = _this.handleOutClick.bind(_this);
        var _a = _this.props, format = _a.format, joinValues = _a.joinValues, delimiter = _a.delimiter, value = _a.value, inputFormat = _a.inputFormat;
        var _b = DateRangePicker.unFormatValue(value, format, joinValues, delimiter), startDate = _b.startDate, endDate = _b.endDate;
        _this.state = {
            isOpened: false,
            isFocused: false,
            editState: 'start',
            startDate: startDate,
            endDate: endDate,
            oldStartDate: startDate,
            oldEndDate: endDate,
            startInputValue: startDate === null || startDate === void 0 ? void 0 : startDate.format(inputFormat),
            endInputValue: endDate === null || endDate === void 0 ? void 0 : endDate.format(inputFormat),
            endDateOpenedFirst: false
        };
        return _this;
    }
    DateRangePicker.formatValue = function (newValue, format, joinValues, delimiter, utc) {
        var _a, _b;
        if (utc === void 0) { utc = false; }
        newValue = [
            (_a = (utc ? moment__default["default"].utc(newValue.startDate) : newValue.startDate)) === null || _a === void 0 ? void 0 : _a.format(format),
            (_b = (utc ? moment__default["default"].utc(newValue.endDate) : newValue.endDate)) === null || _b === void 0 ? void 0 : _b.format(format)
        ];
        if (joinValues) {
            newValue = newValue.join(delimiter);
        }
        return newValue;
    };
    /* 将日期时间转化为momemnt格式，如果输入的内容不合法则返回undefined */
    DateRangePicker.unFormatValue = function (value, format, joinValues, delimiter) {
        if (!value) {
            return {
                startDate: undefined,
                endDate: undefined
            };
        }
        if (joinValues && typeof value === 'string') {
            value = value.split(delimiter);
        }
        var startDate = moment__default["default"](value === null || value === void 0 ? void 0 : value[0], format);
        var endDate = moment__default["default"](value === null || value === void 0 ? void 0 : value[1], format);
        /**
         * 不合法的value输入都丢弃
         * 注意undefined被moment认为是合法的输入，moment会转化为now，所以需要结合在一起判断
         * @reference https://github.com/moment/moment/issues/1639
         */
        return {
            startDate: value[0] && startDate.isValid() ? startDate : undefined,
            endDate: value[1] && endDate.isValid() ? endDate : undefined
        };
    };
    DateRangePicker.prototype.componentDidMount = function () {
        var _a, _b;
        document.body.addEventListener('click', this.handleOutClick, true);
        (_b = (_a = this.props) === null || _a === void 0 ? void 0 : _a.onRef) === null || _b === void 0 ? void 0 : _b.call(_a, this);
    };
    DateRangePicker.prototype.componentWillUnmount = function () {
        document.body.removeEventListener('click', this.handleOutClick, true);
    };
    DateRangePicker.prototype.handleOutClick = function (e) {
        if (!e.target ||
            !this.dom.current ||
            this.dom.current.contains(e.target) ||
            !this.calendarRef.current ||
            this.calendarRef.current.contains(e.target)) {
            return;
        }
        if (this.state.isOpened) {
            e.preventDefault();
            this.close();
        }
    };
    DateRangePicker.prototype.componentDidUpdate = function (prevProps) {
        var props = this.props;
        var value = props.value, format = props.format, joinValues = props.joinValues, inputFormat = props.inputFormat, delimiter = props.delimiter;
        if (prevProps.value !== value) {
            var _a = DateRangePicker.unFormatValue(value, format, joinValues, delimiter), startDate = _a.startDate, endDate = _a.endDate;
            this.setState({
                startDate: startDate,
                endDate: endDate,
                startInputValue: startDate && (startDate === null || startDate === void 0 ? void 0 : startDate.isValid())
                    ? startDate === null || startDate === void 0 ? void 0 : startDate.format(inputFormat)
                    : '',
                endInputValue: endDate && (endDate === null || endDate === void 0 ? void 0 : endDate.isValid()) ? endDate === null || endDate === void 0 ? void 0 : endDate.format(inputFormat) : ''
            });
        }
    };
    DateRangePicker.prototype.focus = function () {
        if (!this.dom.current || this.props.disabled) {
            return;
        }
        this.dom.current.focus();
    };
    DateRangePicker.prototype.blur = function () {
        if (!this.dom.current || this.props.disabled) {
            return;
        }
        this.dom.current.blur();
    };
    DateRangePicker.prototype.handleFocus = function (e) {
        this.setState({
            isFocused: true
        });
        var onFocus = this.props.onFocus;
        onFocus && onFocus(e);
    };
    DateRangePicker.prototype.handleBlur = function (e) {
        this.setState({
            isFocused: false
        });
        var onBlur = this.props.onBlur;
        onBlur && onBlur(e);
    };
    DateRangePicker.prototype.open = function () {
        if (this.props.disabled) {
            return;
        }
        this.setState({
            isOpened: true
        });
    };
    DateRangePicker.prototype.openStart = function () {
        if (this.props.disabled) {
            return;
        }
        this.setState({
            isOpened: true,
            editState: 'start'
        });
    };
    DateRangePicker.prototype.openEnd = function () {
        if (this.props.disabled) {
            return;
        }
        this.setState({
            isOpened: true,
            editState: 'end',
            endDateOpenedFirst: true
        });
    };
    DateRangePicker.prototype.close = function (isConfirm) {
        if (isConfirm === void 0) { isConfirm = false; }
        if (!isConfirm) {
            /** 未点击确认关闭时，将日期恢复至未做任何选择的状态 */
            var _a = this.props, value = _a.value, format = _a.format, joinValues = _a.joinValues, delimiter = _a.delimiter, inputFormat = _a.inputFormat;
            var _b = DateRangePicker.unFormatValue(value, format, joinValues, delimiter), startDate = _b.startDate, endDate = _b.endDate;
            this.setState({
                startDate: startDate,
                endDate: endDate,
                oldStartDate: startDate,
                oldEndDate: endDate,
                startInputValue: startDate && moment__default["default"](startDate).isValid()
                    ? startDate.format(inputFormat)
                    : '',
                endInputValue: endDate && moment__default["default"](endDate).isValid()
                    ? endDate.format(inputFormat)
                    : ''
            });
        }
        else {
            this.setState({
                oldStartDate: this.state.startDate,
                oldEndDate: this.state.endDate
            });
        }
        this.setState({
            isOpened: false,
            editState: undefined,
            endDateOpenedFirst: false
        }, this.blur);
    };
    DateRangePicker.prototype.handleClick = function () {
        this.state.isOpened ? this.close() : this.open();
    };
    DateRangePicker.prototype.handlePopOverClick = function (e) {
        e.stopPropagation();
        e.preventDefault();
    };
    DateRangePicker.prototype.handleKeyPress = function (e) {
        if (e.key === ' ') {
            this.handleClick();
            e.preventDefault();
        }
    };
    DateRangePicker.prototype.confirm = function () {
        var _a = this.props, format = _a.format, joinValues = _a.joinValues, delimiter = _a.delimiter, utc = _a.utc;
        var _b = this.state, startDate = _b.startDate, endDate = _b.endDate;
        if (!startDate && !endDate) {
            return;
        }
        else if (endDate && (startDate === null || startDate === void 0 ? void 0 : startDate.isAfter(this.state.endDate))) {
            return;
        }
        this.props.onChange(DateRangePicker.formatValue({ startDate: startDate, endDate: endDate }, format, joinValues, delimiter, utc));
        if (startDate && !endDate) {
            this.setState({ editState: 'end', endDateOpenedFirst: false });
        }
        else {
            this.close(true);
        }
    };
    DateRangePicker.prototype.filterDate = function (date, originValue, timeFormat, type) {
        if (type === void 0) { type = 'start'; }
        var value = date.clone();
        // 没有初始值
        if (!originValue) {
            value = value[type === 'start' ? 'startOf' : 'endOf']('day');
        }
        else if (typeof timeFormat === 'string' && /ss/.test(timeFormat)) {
            value = value[type === 'start' ? 'startOf' : 'endOf']('second');
        }
        else if (typeof timeFormat === 'string' && /mm/.test(timeFormat)) {
            value = value[type === 'start' ? 'startOf' : 'endOf']('minute');
        }
        else if (typeof timeFormat === 'string' && /HH/i.test(timeFormat)) {
            value = value[type === 'start' ? 'startOf' : 'endOf']('hour');
        }
        else if (typeof timeFormat === 'string' && /Q/i.test(timeFormat)) {
            value = value[type === 'start' ? 'startOf' : 'endOf']('quarter');
        }
        else {
            value = value[type === 'start' ? 'startOf' : 'endOf']('day');
        }
        return value;
    };
    DateRangePicker.prototype.handleDateChange = function (newValue) {
        var editState = this.state.editState;
        if (editState === 'start') {
            this.handleStartDateChange(newValue);
        }
        else if (editState === 'end') {
            this.handelEndDateChange(newValue);
        }
    };
    DateRangePicker.prototype.handleStartDateChange = function (newValue) {
        var _a = this.props, timeFormat = _a.timeFormat, minDate = _a.minDate, inputFormat = _a.inputFormat, type = _a.type;
        var _b = this.state, startDate = _b.startDate, endDateOpenedFirst = _b.endDateOpenedFirst;
        if (minDate && newValue.isBefore(minDate)) {
            newValue = minDate;
        }
        var date = this.filterDate(newValue, startDate || minDate, timeFormat, 'start');
        var newState = {
            startDate: date,
            startInputValue: date.format(inputFormat)
        };
        // 这些没有时间的选择点第一次后第二次就是选结束时间
        if (!endDateOpenedFirst &&
            (type === 'input-date-range' ||
                type === 'input-year-range' ||
                type === 'input-quarter-range' ||
                type === 'input-month-range')) {
            newState.editState = 'end';
        }
        this.setState(newState);
    };
    DateRangePicker.prototype.handelEndDateChange = function (newValue) {
        var _this = this;
        var _a = this.props, embed = _a.embed, timeFormat = _a.timeFormat, inputFormat = _a.inputFormat, type = _a.type;
        var _b = this.state; _b.startDate; var endDate = _b.endDate, endDateOpenedFirst = _b.endDateOpenedFirst;
        newValue = this.getEndDateByDuration(newValue);
        var editState = endDateOpenedFirst ? 'start' : 'end';
        var date = this.filterDate(newValue, endDate, timeFormat, 'end');
        this.setState({
            endDate: date,
            endInputValue: date.format(inputFormat)
        }, function () {
            embed && _this.confirm();
        });
        if (type !== 'input-datetime-range') {
            this.setState({ editState: editState });
        }
    };
    // 手动控制输入时间
    DateRangePicker.prototype.startInputChange = function (e) {
        var _a = this.props, onChange = _a.onChange, inputFormat = _a.inputFormat; _a.format; _a.utc;
        var value = e.currentTarget.value;
        this.setState({ startInputValue: value });
        if (value === '') {
            onChange('');
        }
        else {
            var newDate = this.getStartDateByDuration(moment__default["default"](value, inputFormat));
            this.setState({ startDate: newDate });
        }
    };
    DateRangePicker.prototype.endInputChange = function (e) {
        var _a = this.props, onChange = _a.onChange, inputFormat = _a.inputFormat; _a.format; _a.utc;
        var value = e.currentTarget.value;
        this.setState({ endInputValue: value });
        if (value === '') {
            onChange('');
        }
        else {
            var newDate = this.getEndDateByDuration(moment__default["default"](value, inputFormat));
            this.setState({ endDate: newDate });
        }
    };
    // 根据 duration 修复结束时间
    DateRangePicker.prototype.getEndDateByDuration = function (newValue) {
        var _a = this.props, minDuration = _a.minDuration, maxDuration = _a.maxDuration, type = _a.type;
        var _b = this.state, startDate = _b.startDate; _b.endDate; _b.editState;
        if (!startDate) {
            return newValue;
        }
        // 时间范围必须统一成同一天，不然会不一致
        if (type === 'input-time-range' && startDate) {
            newValue.set({
                year: startDate.year(),
                month: startDate.month(),
                date: startDate.date()
            });
        }
        if (minDuration && newValue.isBefore(startDate.clone().add(minDuration))) {
            newValue = startDate.clone().add(minDuration);
        }
        if (maxDuration && newValue.isAfter(startDate.clone().add(maxDuration))) {
            newValue = startDate.clone().add(maxDuration);
        }
        return newValue;
    };
    // 根据 duration 修复起始时间
    DateRangePicker.prototype.getStartDateByDuration = function (newValue) {
        var _a = this.props, minDuration = _a.minDuration, maxDuration = _a.maxDuration, type = _a.type;
        var _b = this.state, endDate = _b.endDate; _b.editState;
        if (!endDate) {
            return newValue;
        }
        // 时间范围必须统一成同一天，不然会不一致
        if (type === 'input-time-range' && endDate) {
            newValue.set({
                year: endDate.year(),
                month: endDate.month(),
                date: endDate.date()
            });
        }
        if (minDuration &&
            newValue.isBefore(endDate.clone().subtract(minDuration))) {
            newValue = endDate.clone().subtract(minDuration);
        }
        if (maxDuration &&
            newValue.isAfter(endDate.clone().subtract(maxDuration))) {
            newValue = endDate.clone().subtract(maxDuration);
        }
        return newValue;
    };
    // 主要用于处理时间的情况
    DateRangePicker.prototype.handleTimeStartChange = function (newValue) {
        var _this = this;
        var _a = this.props, embed = _a.embed; _a.timeFormat; var inputFormat = _a.inputFormat; _a.minDuration; _a.maxDuration; var minDate = _a.minDate;
        var _b = this.state; _b.startDate; var endDate = _b.endDate;
        // 时间范围必须统一成同一天，不然会不一致
        if (endDate) {
            newValue.set({
                year: endDate.year(),
                month: endDate.month(),
                date: endDate.date()
            });
        }
        if (minDate && newValue && newValue.isBefore(minDate, 'second')) {
            newValue = minDate;
        }
        this.setState({
            startDate: newValue,
            startInputValue: newValue.format(inputFormat)
        }, function () {
            embed && _this.confirm();
        });
    };
    DateRangePicker.prototype.handleTimeEndChange = function (newValue) {
        var _this = this;
        var _a = this.props, embed = _a.embed; _a.timeFormat; var inputFormat = _a.inputFormat, minDuration = _a.minDuration, maxDuration = _a.maxDuration, maxDate = _a.maxDate;
        var _b = this.state, startDate = _b.startDate; _b.endDate;
        if (startDate) {
            newValue.set({
                year: startDate.year(),
                month: startDate.month(),
                date: startDate.date()
            });
        }
        if (maxDate && newValue && newValue.isAfter(maxDate, 'second')) {
            newValue = maxDate;
        }
        if (startDate &&
            minDuration &&
            newValue.isBefore(startDate.clone().add(minDuration))) {
            newValue = startDate.clone().add(minDuration);
        }
        if (startDate &&
            maxDuration &&
            newValue.isAfter(startDate.clone().add(maxDuration))) {
            newValue = startDate.clone().add(maxDuration);
        }
        this.setState({
            endDate: newValue,
            endInputValue: newValue.format(inputFormat)
        }, function () {
            embed && _this.confirm();
        });
    };
    DateRangePicker.prototype.handleMobileChange = function (data, callback) {
        this.setState({
            startDate: data.startDate,
            endDate: data.endDate
        }, callback);
    };
    DateRangePicker.prototype.selectRannge = function (range) {
        var _a = this.props, closeOnSelect = _a.closeOnSelect, minDate = _a.minDate, maxDate = _a.maxDate;
        var now = moment__default["default"]();
        this.setState({
            startDate: minDate && minDate.isValid()
                ? moment__default["default"].max(range.startDate(now.clone()), minDate)
                : range.startDate(now.clone()),
            endDate: maxDate && maxDate.isValid()
                ? moment__default["default"].min(maxDate, range.endDate(now.clone()))
                : range.endDate(now.clone())
        }, closeOnSelect ? this.confirm : amisCore.noop);
    };
    DateRangePicker.prototype.renderRanges = function (ranges) {
        var _this = this;
        if (!ranges) {
            return null;
        }
        var ns = this.props.classPrefix;
        var rangeArr;
        if (typeof ranges === 'string') {
            rangeArr = ranges.split(',');
        }
        else {
            rangeArr = ranges;
        }
        var __ = this.props.translate;
        return (React__default["default"].createElement("ul", { className: "".concat(ns, "DateRangePicker-rangers") }, rangeArr.map(function (item) {
            if (!item) {
                return null;
            }
            var range = {};
            if (typeof item === 'string') {
                if (availableRanges[item]) {
                    range = availableRanges[item];
                    range.key = item;
                }
                else {
                    // 通过正则尝试匹配
                    for (var i = 0, len = advancedRanges.length; i < len; i++) {
                        var value = advancedRanges[i];
                        var m = value.regexp.exec(item);
                        if (m) {
                            range = value.resolve.apply(item, tslib.__spreadArray([__], tslib.__read(m), false));
                            range.key = item;
                        }
                    }
                }
            }
            else if (item.startDate &&
                item.endDate) {
                range = tslib.__assign(tslib.__assign({}, item), { startDate: function () { return item.startDate; }, endDate: function () { return item.endDate; } });
            }
            if (Object.keys(range).length) {
                return (React__default["default"].createElement("li", { className: "".concat(ns, "DateRangePicker-ranger"), onClick: function () { return _this.selectRannge(range); }, key: range.key || range.label },
                    React__default["default"].createElement("a", null, __(range.label))));
            }
            else {
                return null;
            }
        })));
    };
    DateRangePicker.prototype.clearValue = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var onChange = this.props.onChange;
        this.setState({ startInputValue: '', endInputValue: '' });
        onChange('');
    };
    // 清空
    DateRangePicker.prototype.clear = function () {
        var onChange = this.props.onChange;
        this.setState({ startInputValue: '', endInputValue: '' });
        onChange('');
    };
    // 重置
    DateRangePicker.prototype.reset = function () {
        var _a = this.props, resetValue = _a.resetValue, onChange = _a.onChange, format = _a.format, joinValues = _a.joinValues, delimiter = _a.delimiter, inputFormat = _a.inputFormat;
        if (!resetValue) {
            return;
        }
        var _b = DateRangePicker.unFormatValue(resetValue, format, joinValues, delimiter), startDate = _b.startDate, endDate = _b.endDate;
        onChange(resetValue);
        this.setState({
            startInputValue: startDate === null || startDate === void 0 ? void 0 : startDate.format(inputFormat),
            endInputValue: endDate === null || endDate === void 0 ? void 0 : endDate.format(inputFormat)
        });
    };
    DateRangePicker.prototype.checkStartIsValidDate = function (currentDate) {
        var _a = this.state, endDate = _a.endDate; _a.startDate;
        var _b = this.props, minDate = _b.minDate, maxDate = _b.maxDate, minDuration = _b.minDuration, maxDuration = _b.maxDuration, viewMode = _b.viewMode;
        var precision = viewMode === 'time' ? 'hours' : viewMode || 'day';
        maxDate =
            maxDate && endDate
                ? maxDate.isBefore(endDate)
                    ? maxDate
                    : endDate
                : maxDate || endDate;
        if (minDate && currentDate.isBefore(minDate, precision)) {
            return false;
        }
        else if (maxDate && currentDate.isAfter(maxDate, precision)) {
            return false;
        }
        else if (
        // 如果配置了 minDuration 那么 EndDate - minDuration 之后的天数也不能选
        endDate &&
            minDuration &&
            currentDate.isAfter(endDate.clone().subtract(minDuration))) {
            return false;
        }
        else if (endDate &&
            maxDuration &&
            currentDate.isBefore(endDate.clone().subtract(maxDuration))) {
            return false;
        }
        return true;
    };
    DateRangePicker.prototype.checkEndIsValidDate = function (currentDate) {
        var startDate = this.state.startDate;
        var _a = this.props, minDate = _a.minDate, maxDate = _a.maxDate, minDuration = _a.minDuration, maxDuration = _a.maxDuration, viewMode = _a.viewMode;
        var precision = viewMode === 'time' ? 'hours' : viewMode || 'day';
        minDate =
            minDate && startDate
                ? minDate.isAfter(startDate)
                    ? minDate
                    : startDate
                : minDate || startDate;
        // 在 dateTimeRange 的场景下，如果选择了开始时间的时间点不为 0，比如 2020-10-1 10:10，这时 currentDate 传入的当天值是 2020-10-1 00:00，这个值在起始时间后面，导致没法再选这一天了，所以在这时需要先通过将时间都转成 00 再比较
        if (minDate &&
            currentDate
                .startOf('day')
                .isBefore(minDate.clone().startOf('day'), precision)) {
            return false;
        }
        else if (maxDate && currentDate.isAfter(maxDate, precision)) {
            return false;
        }
        else if (startDate &&
            minDuration &&
            currentDate.isBefore(startDate.clone().add(minDuration))) {
            return false;
        }
        else if (startDate &&
            maxDuration &&
            currentDate.isAfter(startDate.clone().add(maxDuration))) {
            return false;
        }
        return true;
    };
    DateRangePicker.prototype.renderDay = function (props, currentDate) {
        var _a = this.state, startDate = _a.startDate, endDate = _a.endDate;
        if (startDate &&
            endDate &&
            currentDate.isBetween(startDate, endDate, 'day', '[]')) {
            props.className += ' rdtBetween';
        }
        if (startDate && currentDate.isSame(startDate, 'day')) {
            props.className += ' rdtActive rdtStartDay';
        }
        if (endDate && currentDate.isSame(endDate, 'day')) {
            props.className += ' rdtActive rdtEndDay';
        }
        var _b = this.getDisabledElementProps(currentDate, 'day'), className = _b.className, others = tslib.__rest(_b, ["className"]);
        props.className += className;
        return (React__default["default"].createElement("td", tslib.__assign({}, omit__default["default"](props, ['todayActiveStyle']), others),
            React__default["default"].createElement("span", null, currentDate.date())));
    };
    DateRangePicker.prototype.renderMonth = function (props, month, year, date) {
        var m = moment__default["default"]();
        var currentDate = m.year(year).month(month);
        var _a = this.state, startDate = _a.startDate, endDate = _a.endDate;
        var localMoment = m.localeData().monthsShort(m.month(month));
        var strLength = 3;
        var monthStrFixedLength = localMoment.substring(0, strLength);
        if (startDate &&
            endDate &&
            currentDate.isBetween(startDate, endDate, 'month', '[]')) {
            props.className += ' rdtBetween';
        }
        var _b = this.getDisabledElementProps(currentDate, 'month'), className = _b.className, others = tslib.__rest(_b, ["className"]);
        props.className += className;
        return (React__default["default"].createElement("td", tslib.__assign({}, props, others),
            React__default["default"].createElement("span", null, monthStrFixedLength)));
    };
    DateRangePicker.prototype.renderQuarter = function (props, quarter, year) {
        var currentDate = moment__default["default"]().year(year).quarter(quarter);
        var _a = this.state, startDate = _a.startDate, endDate = _a.endDate;
        if (startDate &&
            endDate &&
            currentDate.isBetween(startDate, endDate, 'quarter', '[]')) {
            props.className += ' rdtBetween';
        }
        var _b = this.getDisabledElementProps(currentDate, 'quarter'), className = _b.className, others = tslib.__rest(_b, ["className"]);
        props.className += className;
        return (React__default["default"].createElement("td", tslib.__assign({}, props, others),
            React__default["default"].createElement("span", null,
                "Q",
                quarter)));
    };
    DateRangePicker.prototype.renderYear = function (props, year) {
        var currentDate = moment__default["default"]().year(year);
        var _a = this.state, startDate = _a.startDate, endDate = _a.endDate;
        if (startDate &&
            endDate &&
            currentDate.isBetween(startDate, endDate, 'year', '[]')) {
            props.className += ' rdtBetween';
        }
        var _b = this.getDisabledElementProps(currentDate, 'year'), className = _b.className, others = tslib.__rest(_b, ["className"]);
        props.className += className;
        return (React__default["default"].createElement("td", tslib.__assign({}, props, others),
            React__default["default"].createElement("span", null, year)));
    };
    DateRangePicker.prototype.renderCalendar = function () {
        var _this = this;
        var _a = this.props, ns = _a.classPrefix, cx = _a.classnames, dateFormat = _a.dateFormat, timeFormat = _a.timeFormat, inputFormat = _a.inputFormat, ranges = _a.ranges, locale = _a.locale, embed = _a.embed, type = _a.type, _b = _a.viewMode, viewMode = _b === void 0 ? 'days' : _b;
        var __ = this.props.translate;
        var _c = this.state, startDate = _c.startDate, endDate = _c.endDate, editState = _c.editState;
        var isDateTimeRange = type === 'input-datetime-range';
        var isDateRange = type === 'input-date-range';
        // timeRange需要单独选择范围
        var isTimeRange = isDateTimeRange || viewMode === 'time';
        var isConfirmBtnDisbaled = (isTimeRange && editState === 'start' && !startDate) ||
            (isTimeRange && editState === 'end' && !endDate) ||
            (startDate && (endDate === null || endDate === void 0 ? void 0 : endDate.isBefore(this.state.startDate))) ||
            /** 日期范围选择之后会立即切换面板，所以开始/结束日期任意一个不合法就不允许更新数据 */
            (isDateRange &&
                (!startDate ||
                    !endDate ||
                    !(startDate === null || startDate === void 0 ? void 0 : startDate.isValid()) ||
                    !(endDate === null || endDate === void 0 ? void 0 : endDate.isValid())));
        return (React__default["default"].createElement("div", { className: cx("".concat(ns, "DateRangePicker-wrap")), ref: this.calendarRef },
            this.renderRanges(ranges),
            React__default["default"].createElement("div", { className: cx("".concat(ns, "DateRangePicker-picker-wrap")) },
                (!isTimeRange || (editState === 'start' && !embed)) && (React__default["default"].createElement(Calendar["default"], { className: "".concat(ns, "DateRangePicker-start"), value: startDate, 
                    // 区分的原因是 time-range 左侧就只能选起始时间，而其它都能在左侧同时同时选择起始和结束
                    // TODO: 后续得把 time-range 代码拆分出来
                    onChange: isDateTimeRange
                        ? this.handleStartDateChange
                        : viewMode === 'time'
                            ? this.handleTimeStartChange
                            : this.handleDateChange, requiredConfirm: false, dateFormat: dateFormat, inputFormat: inputFormat, timeFormat: timeFormat, isValidDate: this.checkStartIsValidDate, viewMode: viewMode, input: false, onClose: this.close, renderDay: this.renderDay, renderMonth: this.renderMonth, renderQuarter: this.renderQuarter, renderYear: this.renderYear, locale: locale, timeRangeHeader: "\u5F00\u59CB\u65F6\u95F4" })),
                (!isTimeRange || (editState === 'end' && !embed)) && (React__default["default"].createElement(Calendar["default"], { className: "".concat(ns, "DateRangePicker-end"), value: endDate, onChange: isDateTimeRange
                        ? this.handelEndDateChange
                        : viewMode === 'time'
                            ? this.handleTimeEndChange
                            : this.handleDateChange, requiredConfirm: false, dateFormat: dateFormat, inputFormat: inputFormat, timeFormat: timeFormat, viewDate: isDateTimeRange ? this.currentMonth : this.nextMonth, 
                    // isEndDate
                    isValidDate: this.checkEndIsValidDate, viewMode: viewMode, input: false, onClose: this.close, renderDay: this.renderDay, renderMonth: this.renderMonth, renderQuarter: this.renderQuarter, renderYear: this.renderYear, locale: locale, timeRangeHeader: "\u7ED3\u675F\u65F6\u95F4" }))),
            embed ? null : (React__default["default"].createElement("div", { key: "button", className: "".concat(ns, "DateRangePicker-actions") },
                React__default["default"].createElement(Button["default"], { size: "sm", onClick: function () { return _this.close(); } }, __('cancel')),
                React__default["default"].createElement(Button["default"], { level: "primary", size: "sm", className: cx('m-l-sm'), disabled: isConfirmBtnDisbaled, onClick: this.confirm }, __('confirm'))))));
    };
    DateRangePicker.prototype.getDisabledElementProps = function (currentDate, granularity) {
        var _a = this.state; _a.endDateOpenedFirst; var endDate = _a.endDate, startDate = _a.startDate, editState = _a.editState;
        var afterEndDate = editState === 'start' && currentDate.isAfter(endDate, granularity);
        var beforeStartDate = editState === 'end' &&
            !currentDate.isSameOrAfter(startDate, granularity);
        if (afterEndDate || beforeStartDate) {
            return {
                className: ' is-disabled',
                onClick: undefined
            };
        }
        return {
            className: ''
        };
    };
    /** 获取宽度类型变量的值 */
    DateRangePicker.prototype.getValidWidthValue = function (element, propsName) {
        if (!element || !propsName) {
            return 0;
        }
        var propsValue = parseInt(amisCore.getComputedStyle(element, kebabCase__default["default"](propsName)), 10);
        return isNaN(propsValue) ? 0 : propsValue;
    };
    DateRangePicker.prototype.renderActiveCursor = function () {
        var _a, _b, _c, _d;
        var cx = this.props.classnames;
        var _e = this.state, editState = _e.editState, isFocused = _e.isFocused;
        var cursorWidth = 0;
        var cursorLeft = 0;
        var parentNode = (_a = this === null || this === void 0 ? void 0 : this.dom) === null || _a === void 0 ? void 0 : _a.current;
        var startInputNode = (_b = this === null || this === void 0 ? void 0 : this.startInputRef) === null || _b === void 0 ? void 0 : _b.current;
        var endInputNode = (_c = this === null || this === void 0 ? void 0 : this.endInputRef) === null || _c === void 0 ? void 0 : _c.current;
        var separatorNode = (_d = this === null || this === void 0 ? void 0 : this.separatorRef) === null || _d === void 0 ? void 0 : _d.current;
        if (parentNode && startInputNode && endInputNode && separatorNode) {
            if (editState === 'start') {
                var paddingWidth = this.getValidWidthValue(parentNode, 'paddingLeft');
                cursorLeft = paddingWidth;
                cursorWidth = startInputNode.offsetWidth;
            }
            else if (editState === 'end') {
                var separatorWidth = separatorNode.offsetWidth +
                    this.getValidWidthValue(parentNode, 'paddingLeft') +
                    this.getValidWidthValue(parentNode, 'marginLeft') +
                    this.getValidWidthValue(parentNode, 'paddingRight') +
                    this.getValidWidthValue(parentNode, 'marginRight');
                cursorLeft = startInputNode.offsetWidth + separatorWidth;
                cursorWidth = endInputNode.offsetWidth;
            }
            else {
                cursorWidth = 0;
            }
        }
        return (React__default["default"].createElement("div", { className: cx('DateRangePicker-activeCursor', { isFocused: isFocused }), style: {
                position: 'absolute',
                left: cursorLeft,
                width: cursorWidth
            } }));
    };
    DateRangePicker.prototype.render = function () {
        var _a;
        var _this = this;
        var _b = this.props, className = _b.className, popoverClassName = _b.popoverClassName, ns = _b.classPrefix, cx = _b.classnames, value = _b.value, startPlaceholder = _b.startPlaceholder, endPlaceholder = _b.endPlaceholder, popOverContainer = _b.popOverContainer, inputFormat = _b.inputFormat; _b.format; _b.joinValues; _b.delimiter; var clearable = _b.clearable, disabled = _b.disabled, embed = _b.embed, overlayPlacement = _b.overlayPlacement, borderMode = _b.borderMode, useMobileUI = _b.useMobileUI, timeFormat = _b.timeFormat, minDate = _b.minDate, maxDate = _b.maxDate, minDuration = _b.minDuration, maxDuration = _b.maxDuration, dateFormat = _b.dateFormat, _c = _b.viewMode, viewMode = _c === void 0 ? 'days' : _c, ranges = _b.ranges, label = _b.label, animation = _b.animation;
        var useCalendarMobile = useMobileUI &&
            amisCore.isMobile() &&
            ['days', 'months', 'quarters'].indexOf(viewMode) > -1;
        var _d = this.state, isOpened = _d.isOpened, isFocused = _d.isFocused, startDate = _d.startDate, endDate = _d.endDate;
        var __ = this.props.translate;
        var calendarMobile = (React__default["default"].createElement(CalendarMobile["default"], { timeFormat: timeFormat, inputFormat: inputFormat, startDate: startDate, endDate: endDate, minDate: minDate, maxDate: maxDate, minDuration: minDuration, maxDuration: maxDuration, dateFormat: dateFormat, embed: embed, viewMode: viewMode, close: this.close, confirm: this.confirm, onChange: this.handleMobileChange, footerExtra: this.renderRanges(ranges), showViewMode: viewMode === 'quarters' || viewMode === 'months' ? 'years' : 'months' }));
        if (embed) {
            return (React__default["default"].createElement("div", { className: cx("".concat(ns, "DateRangeCalendar"), {
                    'is-disabled': disabled
                }, className) }, useCalendarMobile ? calendarMobile : this.renderCalendar()));
        }
        var CalendarMobileTitle = (React__default["default"].createElement("div", { className: "".concat(ns, "CalendarMobile-title") }, label && typeof label === 'string' ? label : __('Calendar.datepicker')));
        /** 是否启用游标动画 */
        var useAnimation = animation !== false;
        return (React__default["default"].createElement("div", { tabIndex: 0, onKeyPress: this.handleKeyPress, onFocus: this.handleFocus, onBlur: this.handleBlur, className: cx("".concat(ns, "DateRangePicker"), (_a = {
                    'is-disabled': disabled,
                    'is-focused': isFocused
                },
                _a["".concat(ns, "DateRangePicker--border").concat(amisCore.ucFirst(borderMode))] = borderMode,
                _a['is-mobile'] = useMobileUI && amisCore.isMobile(),
                _a), className), ref: this.dom },
            React__default["default"].createElement(Input["default"], { className: cx('DateRangePicker-input', {
                    isActive: !useAnimation && this.state.editState === 'start' && isOpened
                }), onChange: this.startInputChange, onClick: this.openStart, ref: this.startInputRef, placeholder: __(startPlaceholder), autoComplete: "off", value: this.state.startInputValue || '', disabled: disabled }),
            React__default["default"].createElement("span", { className: cx('DateRangePicker-input-separator'), ref: this.separatorRef },
                React__default["default"].createElement("span", { className: cx('DateRangePicker-input-separator-line') })),
            React__default["default"].createElement(Input["default"], { className: cx('DateRangePicker-input', {
                    isActive: !useAnimation && this.state.editState === 'end' && isOpened
                }), onChange: this.endInputChange, onClick: this.openEnd, ref: this.endInputRef, placeholder: __(endPlaceholder), autoComplete: "off", value: this.state.endInputValue || '', disabled: disabled }),
            useAnimation ? this.renderActiveCursor() : null,
            clearable && !disabled && value ? (React__default["default"].createElement("a", { className: "".concat(ns, "DateRangePicker-clear"), onClick: this.clearValue },
                React__default["default"].createElement(icons.Icon, { icon: "input-clear", className: "icon" }))) : null,
            React__default["default"].createElement("a", { className: cx("DateRangePicker-toggler") },
                React__default["default"].createElement(icons.Icon, { icon: viewMode === 'time' ? 'clock' : 'date', className: "icon", iconContent: viewMode === 'time'
                        ? 'DatePicker-toggler-clock'
                        : 'DatePicker-toggler-date' })),
            isOpened ? (useMobileUI && amisCore.isMobile() ? (React__default["default"].createElement(PopUp["default"], { isShow: isOpened, container: popOverContainer, className: cx("".concat(ns, "CalendarMobile-pop"), "".concat(ns, "CalendarMobile-pop--").concat(viewMode)), onHide: this.close, header: CalendarMobileTitle }, useCalendarMobile ? calendarMobile : this.renderCalendar())) : (React__default["default"].createElement(amisCore.Overlay, { target: function () { return _this.dom.current; }, onHide: this.close, container: popOverContainer || (function () { return ReactDOM.findDOMNode(_this); }), rootClose: false, placement: overlayPlacement, show: true },
                React__default["default"].createElement(amisCore.PopOver, { classPrefix: ns, className: cx("".concat(ns, "DateRangePicker-popover"), popoverClassName), onHide: this.close, onClick: this.handlePopOverClick }, this.renderCalendar())))) : null));
    };
    DateRangePicker.defaultProps = {
        startPlaceholder: 'Calendar.startPick',
        endPlaceholder: 'Calendar.endPick',
        format: 'X',
        inputFormat: 'YYYY-MM-DD',
        joinValues: true,
        clearable: true,
        delimiter: ',',
        ranges: 'yesterday,7daysago,prevweek,thismonth,prevmonth,prevquarter',
        resetValue: '',
        closeOnSelect: true,
        overlayPlacement: 'auto',
        endDateOpenedFirst: false
    };
    return DateRangePicker;
}(React__default["default"].Component));
var DateRangePicker$1 = amisCore.themeable(amisCore.localeable(DateRangePicker));

exports.DateRangePicker = DateRangePicker;
exports.advancedRanges = advancedRanges;
exports.availableRanges = availableRanges;
exports["default"] = DateRangePicker$1;
