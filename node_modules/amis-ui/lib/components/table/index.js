/**
 * amis-ui v2.9.0
 * Copyright 2018-2023 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var ReactDOM = require('react-dom');
var findLastIndex = require('lodash/findLastIndex');
var find = require('lodash/find');
var isEqual = require('lodash/isEqual');
var filter = require('lodash/filter');
var intersection = require('lodash/intersection');
var Sortable = require('sortablejs');
var amisCore = require('amis-core');
var icons = require('../icons.js');
var Checkbox = require('../Checkbox.js');
var Spinner = require('../Spinner.js');
var HeadCellSort = require('./HeadCellSort.js');
var HeadCellFilter = require('./HeadCellFilter.js');
var HeadCellSelect = require('./HeadCellSelect.js');
var ItemActionsWrapper = require('./ItemActionsWrapper.js');
var Cell = require('./Cell.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var findLastIndex__default = /*#__PURE__*/_interopDefaultLegacy(findLastIndex);
var find__default = /*#__PURE__*/_interopDefaultLegacy(find);
var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);
var filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);
var intersection__default = /*#__PURE__*/_interopDefaultLegacy(intersection);
var Sortable__default = /*#__PURE__*/_interopDefaultLegacy(Sortable);

/**
 * @file Table
 * @author fex
 */
function getMaxLevelThRowSpan(columns) {
    var maxLevel = 0;
    Array.isArray(columns) &&
        columns.forEach(function (c) {
            var level = getThRowSpan(c);
            if (maxLevel < level) {
                maxLevel = level;
            }
        });
    return maxLevel;
}
function getThRowSpan(column) {
    if (!column.children || (column.children && !column.children.length)) {
        return 1;
    }
    return 1 + getMaxLevelThRowSpan(column.children);
}
function getThColSpan(column) {
    if (!column.children || (column.children && !column.children.length)) {
        return 1;
    }
    var childrenLength = 0;
    column.children.forEach(function (item) { return (childrenLength += getThColSpan(item)); });
    return childrenLength;
}
function buildColumns(columns, thColumns, tdColumns, maxLevel, depth, id, fixed) {
    if (columns === void 0) { columns = []; }
    if (tdColumns === void 0) { tdColumns = []; }
    if (depth === void 0) { depth = 0; }
    // 在处理表头时，如果父级column设置了fixed属性，那么所有children保持一致
    Array.isArray(columns) &&
        columns.forEach(function (column) {
            var groupId = id || amisCore.guid();
            var childMaxLevel = 0;
            if (column.children) {
                childMaxLevel = getMaxLevelThRowSpan(column.children);
            }
            var newColumn = tslib.__assign(tslib.__assign({}, column), { rowSpan: childMaxLevel ? 1 : maxLevel - depth, colSpan: getThColSpan(column), groupId: groupId, depth: depth });
            var tdColumn = tslib.__assign(tslib.__assign({}, column), { groupId: groupId });
            if (fixed) {
                newColumn.fixed = fixed;
                tdColumn.fixed = fixed;
            }
            if (!thColumns[depth]) {
                thColumns[depth] = [];
            }
            thColumns[depth].push(newColumn);
            if (column.children && column.children.length > 0) {
                buildColumns(column.children, thColumns, tdColumns, maxLevel, depth + 1, groupId, column.fixed);
            }
            else {
                tdColumn.children; var rest = tslib.__rest(tdColumn, ["children"]);
                tdColumns.push(rest);
            }
        });
}
function isFixedLeftColumn(fixed) {
    return fixed === true || fixed === 'left';
}
function isFixedRightColumn(fixed) {
    return fixed === 'right';
}
function getPreviousLeftWidth(doms, index, columns) {
    var width = 0;
    for (var i = 0; i < index; i++) {
        if (columns && columns[i] && isFixedLeftColumn(columns[i].fixed)) {
            var dom = doms[i];
            width += dom.offsetWidth;
        }
    }
    return width;
}
function getAfterRightWidth(doms, index, columns) {
    var width = 0;
    for (var i = doms.length - 0; i > index; i--) {
        if (columns && columns[i] && isFixedRightColumn(columns[i].fixed)) {
            var dom = doms[i];
            width += dom.offsetWidth;
        }
    }
    return width;
}
function hasFixedColumn(columns) {
    return find__default["default"](columns, function (column) { return column.fixed; });
}
function getSummaryColumns(summary) {
    if (!summary) {
        return [];
    }
    var last = [];
    var first = [];
    summary.forEach(function (item) {
        if (amisCore.isObject(item)) {
            first.push(item);
        }
        else if (Array.isArray(item)) {
            last.push(item);
        }
    });
    return tslib.__spreadArray([first], tslib.__read(last), false);
}
var DefaultCellWidth = 40;
var Table = /** @class */ (function (_super) {
    tslib.__extends(Table, _super);
    function Table(props) {
        var _this = this;
        var _a;
        _this = _super.call(this, props) || this;
        _this.tableDom = React__default["default"].createRef();
        _this.theadDom = React__default["default"].createRef();
        _this.tbodyDom = React__default["default"].createRef();
        _this.contentDom = React__default["default"].createRef();
        _this.headerDom = React__default["default"].createRef();
        _this.bodyDom = React__default["default"].createRef();
        _this.tfootDom = React__default["default"].createRef();
        _this.footDom = React__default["default"].createRef();
        if (props.rowSelection) {
            var selectedResult = _this.getSelectedRows(props.dataSource, (_a = props.rowSelection) === null || _a === void 0 ? void 0 : _a.selectedRowKeys);
            _this.selectedRows = selectedResult.selectedRows;
            _this.unSelectedRows = selectedResult.unSelectedRows;
        }
        _this.state = {
            selectedRowKeys: props.rowSelection
                ? props.rowSelection.selectedRowKeys.map(function (key) { return key; }) || []
                : [],
            dataSource: props.dataSource || [],
            expandedRowKeys: tslib.__spreadArray(tslib.__spreadArray([], tslib.__read((props.expandable ? props.expandable.expandedRowKeys || [] : [])), false), tslib.__read((props.expandable
                ? props.expandable.defaultExpandedRowKeys || []
                : [])), false),
            colWidths: [],
            hoverRow: null
        };
        return _this;
    }
    Table.prototype.getPopOverContainer = function () {
        return ReactDOM.findDOMNode(this);
    };
    Table.prototype.getColWidths = function () {
        var _a, _b;
        var childrens = ((_b = (_a = this.tbodyDom.current) === null || _a === void 0 ? void 0 : _a.children[0]) === null || _b === void 0 ? void 0 : _b.children) || [];
        var colWidths = new Array(childrens ? childrens.length : 0);
        // 分2个table实现表格 为了实现上下table的宽度统一
        for (var i = 0; i < childrens.length; i++) {
            var child = childrens[i];
            colWidths[i] = child ? child.offsetWidth : null;
        }
        return colWidths;
    };
    Table.prototype.getSelectedRows = function (dataSource, selectedRowKeys) {
        var _this = this;
        var selectedRows = [];
        var unSelectedRows = [];
        dataSource.forEach(function (data) {
            if (find__default["default"](selectedRowKeys, function (key) { return key === data[_this.getRowSelectionKeyField()]; })) {
                selectedRows.push(data);
            }
            else {
                unSelectedRows.push(data);
            }
        });
        return { selectedRows: selectedRows, unSelectedRows: unSelectedRows };
    };
    Table.prototype.updateTableBodyFixed = function () {
        var tbodyDom = this.tbodyDom && this.tbodyDom.current;
        var tdColumns = tslib.__spreadArray([], tslib.__read(this.tdColumns), false);
        if (!tbodyDom) {
            return;
        }
        this.updateTbodyFixedRow(tbodyDom, tdColumns);
        this.updateHeadSummaryFixedRow(tbodyDom);
    };
    Table.prototype.updateColWidths = function () {
        var _this = this;
        this.setState({ colWidths: this.getColWidths() }, function () {
            if (hasFixedColumn(_this.props.columns)) {
                var theadDom = _this.theadDom && _this.theadDom.current;
                var thColumns = _this.thColumns;
                _this.updateTheadFixedRow(theadDom, thColumns);
                _this.updateTableBodyFixed();
            }
        });
    };
    Table.prototype.updateTableFixedRows = function () {
        if (hasFixedColumn(this.props.columns)) {
            var headerDom = this.headerDom && this.headerDom.current;
            if (headerDom) {
                var headerBody = headerDom.getElementsByTagName('tbody');
                headerBody &&
                    headerBody[0] &&
                    this.updateHeadSummaryFixedRow(headerBody[0]);
            }
            var tfootDom = this.tfootDom && this.tfootDom.current;
            tfootDom && this.updateFootSummaryFixedRow(tfootDom);
        }
    };
    Table.prototype.componentDidMount = function () {
        var _this = this;
        var _a, _b, _c, _d;
        (_b = (_a = this.props) === null || _a === void 0 ? void 0 : _a.onRef) === null || _b === void 0 ? void 0 : _b.call(_a, this);
        if (this.props.loading) {
            return;
        }
        this.updateTableFixedRows();
        var current = (_c = this.contentDom) === null || _c === void 0 ? void 0 : _c.current;
        if ((_d = this.headerDom) === null || _d === void 0 ? void 0 : _d.current) {
            // overflow设置为hidden的情况
            var hiddenDomRefs = [this.headerDom, this.footDom];
            hiddenDomRefs.forEach(function (ref) {
                return ref &&
                    ref.current &&
                    ref.current.addEventListener('wheel', _this.onWheel.bind(_this));
            });
        }
        current && this.updateTableDom(current);
        if (this.props.draggable) {
            this.initDragging();
        }
        this.updateStickyHeader();
        this.updateColWidths();
    };
    Table.prototype.componentDidUpdate = function (prevProps, prevState) {
        var _this = this;
        var _a, _b, _c, _d;
        // 数据源发生了变化
        if (!isEqual__default["default"](prevProps.dataSource, this.props.dataSource)) {
            this.setState({ dataSource: tslib.__spreadArray([], tslib.__read(this.props.dataSource), false) }, function () {
                if (_this.props.draggable) {
                    if (_this.sortable) {
                        _this.destroyDragging();
                    }
                    _this.initDragging();
                }
                _this.updateTableFixedRows();
                _this.updateColWidths();
            }); // 异步加载数据需求再更新一次
        }
        // 选择项发生了变化触发
        if (!isEqual__default["default"](prevState.selectedRowKeys, this.state.selectedRowKeys)) {
            // 更新保存的已选择行数据
            var selectedResult = this.getSelectedRows(this.state.dataSource, this.state.selectedRowKeys);
            this.selectedRows = selectedResult.selectedRows;
            this.unSelectedRows = selectedResult.unSelectedRows;
            var rowSelection = this.props.rowSelection;
            rowSelection &&
                rowSelection.onChange &&
                rowSelection.onChange(this.state.selectedRowKeys, this.selectedRows);
            this.setState({
                selectedRowKeys: this.state.selectedRowKeys.filter(function (key, i, a) { return a.indexOf(key) === i; })
            });
        }
        // 外部传入的选择项发生了变化
        if (!isEqual__default["default"]((_a = prevProps.rowSelection) === null || _a === void 0 ? void 0 : _a.selectedRowKeys, (_b = this.props.rowSelection) === null || _b === void 0 ? void 0 : _b.selectedRowKeys)) {
            if (this.props.rowSelection) {
                this.setState({
                    selectedRowKeys: this.props.rowSelection.selectedRowKeys
                });
                var selectedResult = this.getSelectedRows(this.state.dataSource, this.state.selectedRowKeys);
                this.selectedRows = selectedResult.selectedRows;
                this.unSelectedRows = selectedResult.unSelectedRows;
            }
        }
        // 外部传入的展开项发生了变化
        if (!isEqual__default["default"]((_c = prevProps === null || prevProps === void 0 ? void 0 : prevProps.expandable) === null || _c === void 0 ? void 0 : _c.expandedRowKeys, (_d = this.props.expandable) === null || _d === void 0 ? void 0 : _d.expandedRowKeys)) {
            if (this.props.expandable) {
                this.setState({
                    expandedRowKeys: this.props.expandable.expandedRowKeys || []
                });
            }
        }
        // 展开行变化时触发
        if (!isEqual__default["default"](prevState.expandedRowKeys, this.state.expandedRowKeys)) {
            if (this.props.expandable) {
                var _e = this.props.expandable, onExpandedRowsChange = _e.onExpandedRowsChange, keyField_1 = _e.keyField;
                var expandedRows_1 = [];
                this.state.dataSource.forEach(function (item) {
                    if (find__default["default"](_this.state.expandedRowKeys, function (key) { return key == item[keyField_1 || 'key']; })) {
                        expandedRows_1.push(item);
                    }
                });
                onExpandedRowsChange && onExpandedRowsChange(expandedRows_1);
            }
        }
        // sticky属性发生了变化
        if (prevProps.sticky !== this.props.sticky) {
            this.updateStickyHeader();
        }
    };
    Table.prototype.componentWillUnmount = function () {
        var _this = this;
        var hiddenDomRefs = [this.headerDom, this.footDom];
        hiddenDomRefs.forEach(function (ref) {
            return ref &&
                ref.current &&
                ref.current.removeEventListener('wheel', _this.onWheel.bind(_this));
        });
        this.destroyDragging();
    };
    Table.prototype.initDragging = function () {
        var _this = this;
        var _a = this.props, cx = _a.classnames, onDrag = _a.onDrag;
        this.sortable = new Sortable__default["default"](this.tbodyDom.current, {
            group: 'table',
            animation: 150,
            handle: ".".concat(cx('Table-dragCell')),
            ghostClass: 'is-dragging',
            onMove: function (e) {
                var dragged = e.dragged;
                var related = e.related;
                if (related &&
                    related.classList.contains("".concat(cx('Table-summary-row')))) {
                    return false;
                }
                var draggedLevels = dragged.getAttribute('row-levels');
                var relatedLevels = related.getAttribute('row-levels');
                // 嵌套展示 不属于同一层的 不允许拖动
                // 否则涉及到试图的更新，比如子元素都被拖完了
                if (draggedLevels !== relatedLevels) {
                    return false;
                }
                return true;
            },
            onEnd: function (e) { return tslib.__awaiter(_this, void 0, void 0, function () {
                var rowLevels;
                return tslib.__generator(this, function (_a) {
                    // 没有移动
                    if (e.newIndex === e.oldIndex) {
                        return [2 /*return*/];
                    }
                    rowLevels = e.item.getAttribute('row-levels');
                    onDrag &&
                        onDrag(e.oldIndex, e.newIndex, rowLevels ? rowLevels.split(',') : []);
                    return [2 /*return*/];
                });
            }); }
        });
    };
    Table.prototype.destroyDragging = function () {
        this.sortable && this.sortable.destroy();
        this.sortable = null;
    };
    Table.prototype.updateStickyHeader = function () {
        var _this = this;
        var _a, _b;
        if (this.props.sticky) {
            // 如果设置了sticky 如果父元素设置了overflow: auto top值还需要考虑padding值
            var parent_1 = (_b = (_a = this.headerDom) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.parentElement;
            setTimeout(function () {
                while (parent_1 &&
                    window.getComputedStyle(parent_1, null).getPropertyValue('overflow') !==
                        'auto') {
                    parent_1 = parent_1.parentElement;
                }
                if (parent_1 &&
                    window.getComputedStyle(parent_1, null).getPropertyValue('overflow') ===
                        'auto') {
                    var paddingTop = window
                        .getComputedStyle(parent_1, null)
                        .getPropertyValue('padding-top');
                    if (paddingTop && _this.headerDom && _this.headerDom.current) {
                        _this.headerDom.current.style.top = '-' + paddingTop;
                    }
                }
            });
        }
    };
    // 更新一个tr下的td的left和class
    Table.prototype.updateFixedRow = function (row, columns) {
        var _a, _b, _c;
        var cx = this.props.classnames;
        var children = row.children;
        for (var i = 0; i < children.length; i++) {
            var dom = children[i];
            var fixed = columns[i] ? columns[i].fixed || '' : '';
            if (isFixedLeftColumn(fixed)) {
                dom.style.left =
                    i > 0 ? getPreviousLeftWidth(children, i, columns) + 'px' : '0';
            }
            else if (isFixedRightColumn(fixed)) {
                dom.style.right =
                    i < children.length - 1
                        ? getAfterRightWidth(children, i, columns) + 'px'
                        : '0';
            }
        }
        // 最后一个左fixed的添加样式
        var leftIndex = findLastIndex__default["default"](columns, function (column) {
            return isFixedLeftColumn(column.fixed);
        });
        if (leftIndex > -1) {
            (_a = children[leftIndex]) === null || _a === void 0 ? void 0 : _a.classList.add(cx('Table-cell-fix-left-last'));
        }
        // 第一个右fixed的添加样式
        var rightIndex = columns.findIndex(function (column) {
            return isFixedRightColumn(column.fixed);
        });
        if (rightIndex > -1) {
            (_b = children[rightIndex]) === null || _b === void 0 ? void 0 : _b.classList.add(cx('Table-cell-fix-right-first'));
            if (rightIndex > 0) {
                (_c = children[rightIndex - 1]) === null || _c === void 0 ? void 0 : _c.classList.add(cx('Table-cell-fix-right-first-prev'));
            }
        }
    };
    // 在可选、可展开、可拖拽的情况下，补充column，方便fix处理
    Table.prototype.prependColumns = function (columns) {
        var _a = this.props, rowSelection = _a.rowSelection, expandable = _a.expandable, draggable = _a.draggable;
        if (draggable) {
            columns.unshift({});
        }
        else {
            if (expandable) {
                columns.unshift(expandable);
            }
            if (rowSelection) {
                columns.unshift(rowSelection);
            }
        }
    };
    Table.prototype.updateTheadFixedRow = function (thead, columns) {
        var children = thead.children;
        for (var i = 0; i < children.length; i++) {
            var cols = tslib.__spreadArray([], tslib.__read(columns[i]), false);
            if (i === 0) {
                this.prependColumns(cols);
            }
            this.updateFixedRow(children[i], cols);
        }
    };
    Table.prototype.updateTbodyFixedRow = function (tbody, columns) {
        var cx = this.props.classnames;
        var children = filter__default["default"](tbody.children, function (child) {
            return !child.classList.contains(cx('Table-summary-row')) &&
                !child.classList.contains(cx('Table-empty-row'));
        });
        this.prependColumns(columns);
        for (var i = 0; i < children.length; i++) {
            this.updateFixedRow(children[i], columns);
        }
    };
    Table.prototype.updateSummaryFixedRow = function (children, columns) {
        for (var i = 0; i < children.length; i++) {
            this.updateFixedRow(children[i], columns[i]);
        }
    };
    Table.prototype.updateFootSummaryFixedRow = function (tfoot) {
        var footSummary = this.props.footSummary;
        if (Array.isArray(footSummary)) {
            var columns = getSummaryColumns(footSummary);
            this.updateSummaryFixedRow(tfoot.children, columns);
        }
    };
    Table.prototype.updateHeadSummaryFixedRow = function (tbody) {
        var _a = this.props, headSummary = _a.headSummary, cx = _a.classnames;
        if (Array.isArray(headSummary)) {
            var columns = getSummaryColumns(headSummary);
            var children = filter__default["default"](tbody.children, function (child) {
                return child.classList.contains(cx('Table-summary-row'));
            });
            this.updateSummaryFixedRow(children, columns);
        }
    };
    Table.prototype.renderColGroup = function (colWidths) {
        var _a = this.props, rowSelection = _a.rowSelection, cx = _a.classnames, expandable = _a.expandable, draggable = _a.draggable;
        var tdColumns = this.tdColumns;
        var isExpandable = this.isExpandableTable();
        var extraCount = this.getExtraColumnCount() - (this.isRightExpandable() ? 1 : 0);
        var isLeftExpandable = this.isLeftExpandable();
        var isRightExpandable = this.isRightExpandable();
        var expandableCol = !draggable && isExpandable ? (React__default["default"].createElement("col", { className: cx('Table-expand-col'), style: {
                width: ((expandable === null || expandable === void 0 ? void 0 : expandable.columnWidth) || DefaultCellWidth) + 'px'
            } })) : null;
        return (React__default["default"].createElement("colgroup", null,
            draggable ? (React__default["default"].createElement("col", { className: cx('Table-drag-col'), style: { width: DefaultCellWidth + 'px' } })) : null,
            !draggable && rowSelection ? (React__default["default"].createElement("col", { className: cx('Table-selection-col'), style: {
                    width: (rowSelection.columnWidth || DefaultCellWidth) + 'px'
                } })) : null,
            isLeftExpandable ? expandableCol : null,
            tdColumns.map(function (data, index) {
                var width = colWidths
                    ? colWidths[index + extraCount - (isRightExpandable ? 1 : 0)]
                    : data.width;
                return (React__default["default"].createElement("col", { key: index, style: { width: typeof width === 'number' ? width + 'px' : width }, className: data.className ? cx("Table-colgroup-".concat(data.className)) : '' }));
            }),
            isRightExpandable ? expandableCol : null));
    };
    Table.prototype.onResizeMouseDown = function (event, index) {
        var _a;
        // 点击记录起始坐标
        this.resizeStart = event.clientX;
        // 用2个table实现的时候 会出现2个colgroup
        // 理论上 宽度要始终保持一致
        var colGroup = (_a = this.tableDom.current) === null || _a === void 0 ? void 0 : _a.getElementsByTagName('colgroup');
        var currentWidth = 0;
        var children = [];
        if (colGroup) {
            for (var i = 0; i < colGroup.length; i++) {
                var child = colGroup[i].children[index];
                if (child) {
                    currentWidth = child.offsetWidth;
                    children.push(child);
                }
            }
        }
        this.resizeWidth = currentWidth;
        this.resizeTarget = children;
        document.addEventListener('mousemove', this.onResizeMouseMove);
        document.addEventListener('mouseup', this.onResizeMouseUp);
        event && event.stopPropagation();
    };
    Table.prototype.onResizeMouseMove = function (event) {
        // 点击了调整列宽
        if (this.resizeStart) {
            // 计算横向移动距离
            var distance = event.clientX - this.resizeStart;
            var newWidth_1 = 0;
            // 调宽列
            // tableLayout为auto情况下 实际宽度并不受width实际控制 表格会根据列内容自动调整
            // 设置scroll.x或者column设置了width 都会将tableLayout设置为fixed
            if (distance > 0) {
                newWidth_1 = this.resizeWidth + distance;
            }
            else {
                // 缩短列
                newWidth_1 = Math.max(this.resizeWidth + distance, DefaultCellWidth);
            }
            this.resizeTarget.forEach(function (target) {
                if (target) {
                    target.style.width = newWidth_1 + 'px';
                }
            });
        }
        event && event.stopPropagation();
    };
    Table.prototype.onResizeMouseUp = function (event) {
        document.removeEventListener('mousemove', this.onResizeMouseMove);
        document.removeEventListener('mouseup', this.onResizeMouseUp);
        this.resizeStart = 0;
        this.resizeWidth = 0;
        this.resizeTarget = [];
    };
    Table.prototype.renderTHead = function () {
        var _this = this;
        var _a = this.props, rowSelection = _a.rowSelection, dataSource = _a.dataSource, cx = _a.classnames, onSort = _a.onSort, expandable = _a.expandable, draggable = _a.draggable, resizable = _a.resizable, onSelectAll = _a.onSelectAll, onFilter = _a.onFilter;
        var thColumns = this.thColumns;
        var tdColumns = this.tdColumns;
        // 获取一行最多th个数
        var maxCount = 0;
        thColumns.forEach(function (columns) {
            if (columns.length > maxCount) {
                maxCount = columns.length;
            }
        });
        var keyField = this.getRowSelectionKeyField();
        var dataList = rowSelection && rowSelection.getCheckboxProps
            ? this.state.dataSource.filter(function (data, index) {
                var props = rowSelection.getCheckboxProps(data, index);
                return !props.disabled;
            })
            : this.state.dataSource;
        var isExpandable = this.isExpandableTable();
        var isLeftExpandable = this.isLeftExpandable();
        var isRightExpandable = this.isRightExpandable();
        var expandableCell = !draggable && isExpandable ? (React__default["default"].createElement(Cell["default"], { wrapperComponent: "th", rowSpan: thColumns.length, fixed: expandable && expandable.fixed ? 'left' : '', className: cx('Table-row-expand-icon-cell') })) : null;
        var allRowKeys = [];
        var allRows = [];
        var maxSelectedLength = rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.maxSelectedLength;
        dataList.forEach(function (data) {
            if (!maxSelectedLength ||
                (!!maxSelectedLength && allRows.length < maxSelectedLength)) {
                allRowKeys.push(data[keyField]);
                allRows.push(data);
                if (!expandable && _this.hasChildrenRow(data)) {
                    allRowKeys = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(allRowKeys), false), tslib.__read(_this.getDataChildrenKeys(data)), false);
                    data[_this.getChildrenColumnName()].forEach(function (item) {
                        return allRows.push(item);
                    });
                }
            }
        });
        return (React__default["default"].createElement("thead", { ref: this.theadDom, className: cx('Table-thead') }, thColumns.map(function (data, index) {
            return (React__default["default"].createElement("tr", { key: 'th-cell-' + index },
                draggable && index === 0 ? (React__default["default"].createElement(Cell["default"], { wrapperComponent: "th", rowSpan: thColumns.length, className: cx('Table-dragCell') })) : null,
                !draggable && rowSelection && index === 0 ? (React__default["default"].createElement(Cell["default"], { wrapperComponent: "th", rowSpan: thColumns.length, fixed: rowSelection.fixed ? 'left' : '', className: cx('Table-checkCell') }, rowSelection.type !== 'radio'
                    ? [
                        React__default["default"].createElement(Checkbox["default"], { key: "checkAll", partial: _this.state.selectedRowKeys.length > 0 &&
                                _this.state.selectedRowKeys.length <
                                    allRowKeys.length, checked: _this.state.selectedRowKeys.length > 0, onChange: function (value) { return tslib.__awaiter(_this, void 0, void 0, function () {
                                var selectedRows, selectedRowKeys, prevented;
                                return tslib.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            selectedRows = value ? allRows : [];
                                            selectedRowKeys = value ? allRowKeys : [];
                                            if (!onSelectAll) return [3 /*break*/, 2];
                                            return [4 /*yield*/, onSelectAll(selectedRows, value ? selectedRowKeys : [], value ? [] : selectedRows)];
                                        case 1:
                                            prevented = _a.sent();
                                            if (prevented) {
                                                return [2 /*return*/];
                                            }
                                            _a.label = 2;
                                        case 2:
                                            this.setState({ selectedRowKeys: selectedRowKeys });
                                            return [2 /*return*/];
                                    }
                                });
                            }); } }),
                        rowSelection.selections &&
                            rowSelection.selections.length > 0 ? (React__default["default"].createElement(HeadCellSelect["default"], { key: "checkSelection", keys: allRowKeys, selections: rowSelection.selections, popOverContainer: _this.getPopOverContainer })) : null
                    ]
                    : null)) : null,
                isLeftExpandable && index === 0 ? expandableCell : null,
                data.map(function (item, i) {
                    var _a, _b, _c;
                    var sort = null;
                    if (item.sorter) {
                        sort = (React__default["default"].createElement(HeadCellSort["default"], { column: item, active: !!((_a = _this.state.sort) === null || _a === void 0 ? void 0 : _a.orderBy) &&
                                _this.state.sort.orderBy === (item === null || item === void 0 ? void 0 : item.name), onSort: function (payload) {
                                _this.setState({
                                    sort: payload
                                });
                                if (onSort) {
                                    onSort(payload);
                                }
                                else {
                                    if (typeof item.sorter === 'function') {
                                        if (payload.orderBy) {
                                            var sortList = tslib.__spreadArray([], tslib.__read(_this.state.dataSource), false);
                                            _this.setState({
                                                dataSource: sortList.sort(item.sorter)
                                            });
                                        }
                                        else {
                                            _this.setState({ dataSource: tslib.__spreadArray([], tslib.__read(dataSource), false) });
                                        }
                                    }
                                }
                            } }));
                    }
                    var filter = null;
                    if (item.filterDropdown) {
                        filter = item.filterDropdown;
                    }
                    else if (item.filters && item.filters.length > 0) {
                        filter = (React__default["default"].createElement(HeadCellFilter["default"], { column: item, popOverContainer: _this.getPopOverContainer, onFilter: onFilter }));
                    }
                    // th的最后一行才可调整列宽
                    // 分组情况下 最后一行才和列配置个数对应
                    // 就可以根据index找到col 不依赖name
                    var noChildren = !((_b = item.children) === null || _b === void 0 ? void 0 : _b.length);
                    var cIndex = -1;
                    if (noChildren) {
                        // 根据name去tdColumns匹配出index
                        // 没设置name的 那一定不是要绑定数据的列 一般都是分组的上层 也不会出现调整列宽
                        cIndex = tdColumns.findIndex(function (c) { return c.name === item.name; });
                    }
                    var children = !((_c = item.children) === null || _c === void 0 ? void 0 : _c.length) ? (React__default["default"].createElement("span", null,
                        React__default["default"].createElement(React__default["default"].Fragment, null,
                            sort,
                            filter,
                            resizable ? (React__default["default"].createElement("i", { className: cx('Table-thead-resizable'), onMouseDown: function (e) { return _this.onResizeMouseDown(e, cIndex); } })) : null))) : null;
                    return (React__default["default"].createElement(Cell["default"], { wrapperComponent: "th", rowSpan: item.rowSpan, colSpan: item.colSpan, key: "cell-".concat(i), fixed: item.fixed === true ? 'left' : item.fixed, className: cx({
                            'Table-cell-last': i === maxCount - 1 && i === data.length - 1
                        }), groupId: item.groupId, depth: item.depth }, typeof item.title === 'function'
                        ? item.title(children)
                        : item.title));
                }),
                isRightExpandable && index === 0 ? expandableCell : null));
        })));
    };
    Table.prototype.onRowClick = function (event, record, rowIndex) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, rowSelection, onRow, prevented, defaultKey_1, isSelected;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.props, rowSelection = _a.rowSelection, onRow = _a.onRow;
                        if (!(onRow && onRow.onRowClick)) return [3 /*break*/, 2];
                        return [4 /*yield*/, onRow.onRowClick(event, record, rowIndex)];
                    case 1:
                        prevented = _b.sent();
                        if (prevented) {
                            return [2 /*return*/];
                        }
                        _b.label = 2;
                    case 2:
                        if (rowSelection && rowSelection.type && rowSelection.rowClick) {
                            defaultKey_1 = this.getRowSelectionKeyField();
                            isSelected = !!find__default["default"](this.state.selectedRowKeys, function (key) { return key === record[defaultKey_1]; });
                            this.selectedSingleRow(!isSelected, record);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Table.prototype.onRowMouseEnter = function (event, record, rowIndex) {
        var _a = this.props, cx = _a.classnames, onRow = _a.onRow;
        var parent = event.target;
        while (parent && parent.tagName !== 'TR') {
            parent = parent.parentElement;
        }
        if (parent && !parent.classList.contains(cx('Table-row-disabled'))) {
            for (var i = 0; i < parent.children.length; i++) {
                var td = parent.children[i];
                td.classList.add(cx('Table-cell-row-hover')); // 保证有列fixed的时候样式一致
            }
        }
        if (record) {
            var target = event.target;
            if (target.tagName !== 'TR') {
                target = target.closest('tr');
            }
            this.setState({ hoverRow: { target: target, rowIndex: rowIndex, record: record } }, function () {
                if (onRow) {
                    onRow.onRowMouseEnter &&
                        onRow.onRowMouseEnter(event, record, rowIndex);
                }
            });
        }
    };
    Table.prototype.onRowMouseLeave = function (event, record, rowIndex) {
        var _a = this.props, cx = _a.classnames, onRow = _a.onRow;
        var parent = event.target;
        while (parent && parent.tagName !== 'TR') {
            parent = parent.parentElement;
        }
        if (parent) {
            for (var i = 0; i < parent.children.length; i++) {
                var td = parent.children[i];
                td.classList.remove(cx('Table-cell-row-hover'));
            }
        }
        if (record) {
            if (onRow) {
                onRow.onRowMouseLeave && onRow.onRowMouseLeave(event, record, rowIndex);
            }
        }
    };
    Table.prototype.onMouseLeave = function () {
        this.setState({ hoverRow: null });
    };
    Table.prototype.onExpandRows = function (data) {
        var _this = this;
        var expandedRowKeys = this.state.expandedRowKeys;
        var expandable = this.props.expandable;
        var keys = data.map(function (d) { return d[_this.getExpandableKeyField()]; });
        this.setState({ expandedRowKeys: tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(expandedRowKeys), false), tslib.__read(keys), false) });
        (expandable === null || expandable === void 0 ? void 0 : expandable.onExpand) && (expandable === null || expandable === void 0 ? void 0 : expandable.onExpand(true, data));
    };
    Table.prototype.onCollapseRows = function (data) {
        var _this = this;
        var expandedRowKeys = this.state.expandedRowKeys;
        var expandable = this.props.expandable;
        var keys = data.map(function (d) { return d[_this.getExpandableKeyField()]; });
        this.setState({
            expandedRowKeys: expandedRowKeys.filter(function (k) { return !keys.find(function (v) { return v == k; }); } // 模糊匹配 否则'3'、3匹配不上
            )
        });
        (expandable === null || expandable === void 0 ? void 0 : expandable.onExpand) && (expandable === null || expandable === void 0 ? void 0 : expandable.onExpand(true, data));
    };
    Table.prototype.getChildrenColumnName = function () {
        var childrenColumnName = this.props.childrenColumnName;
        return childrenColumnName || 'children';
    };
    Table.prototype.getRowSelectionKeyField = function () {
        var rowSelection = this.props.rowSelection;
        return rowSelection ? rowSelection.keyField || 'key' : '';
    };
    Table.prototype.getExpandableKeyField = function () {
        var _a = this.props, expandable = _a.expandable, keyField = _a.keyField;
        return (expandable === null || expandable === void 0 ? void 0 : expandable.keyField) || keyField || 'key';
    };
    Table.prototype.hasChildrenRow = function (data) {
        var key = this.getChildrenColumnName();
        return data[key] && Array.isArray(data[key]) && data[key].length > 0;
    };
    // 展开和嵌套不能共存
    Table.prototype.isExpandableRow = function (data, rowIndex) {
        var expandable = this.props.expandable;
        return (expandable &&
            (!expandable.rowExpandable ||
                (expandable.rowExpandable && expandable.rowExpandable(data, rowIndex))));
    };
    // 获取当前行数据所有子行的key值
    Table.prototype.getDataChildrenKeys = function (data) {
        var _this = this;
        var keys = [];
        if (this.hasChildrenRow(data)) {
            var key = this.getChildrenColumnName();
            data[key].forEach(function (item) {
                return (keys = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(keys), false), tslib.__read(_this.getDataChildrenKeys(item)), false), [
                    item[_this.getRowSelectionKeyField()]
                ], false));
            });
        }
        return keys;
    };
    Table.prototype.hasCheckedRows = function (data) {
        var selectedRowKeys = this.state.selectedRowKeys;
        var childrenKeys = this.getDataChildrenKeys(data);
        return (intersection__default["default"](selectedRowKeys, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(childrenKeys), false), [
            data[this.getRowSelectionKeyField()]
        ], false)).length > 0);
    };
    Table.prototype.hasCheckedChildrenRows = function (data) {
        var selectedRowKeys = this.state.selectedRowKeys;
        var childrenKeys = this.getDataChildrenKeys(data);
        var length = intersection__default["default"](selectedRowKeys, childrenKeys).length;
        return length > 0;
    };
    Table.prototype.isExpanded = function (record) {
        var _this = this;
        return !!find__default["default"](this.state.expandedRowKeys, function (key) { return key == record[_this.getExpandableKeyField()]; }); // == 匹配 否则'3'、3匹配不上
    };
    Table.prototype.getExpandedIcons = function (record) {
        var cx = this.props.classnames;
        return this.isExpanded(record) ? (React__default["default"].createElement("i", { className: cx('Table-expandBtn', 'is-active'), onClick: this.onCollapseRows.bind(this, [record]) },
            React__default["default"].createElement(icons.Icon, { icon: "right-arrow-bold", className: "icon" }))) : (React__default["default"].createElement("i", { className: cx('Table-expandBtn'), onClick: this.onExpandRows.bind(this, [record]) },
            React__default["default"].createElement(icons.Icon, { icon: "right-arrow-bold", className: "icon" })));
    };
    Table.prototype.selectedSingleRow = function (value, data) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, rowSelection, onSelect, defaultKey, isRadio, selectedRowKeys, selectedResult, prevented;
            var _this = this;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.props, rowSelection = _a.rowSelection, onSelect = _a.onSelect;
                        defaultKey = this.getRowSelectionKeyField();
                        isRadio = rowSelection && rowSelection.type === 'radio';
                        selectedRowKeys = [];
                        if (value) {
                            if (isRadio) {
                                selectedRowKeys = [data[defaultKey]];
                            }
                            else {
                                selectedRowKeys = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(this.state.selectedRowKeys), false), [
                                    data[defaultKey]
                                ], false), tslib.__read(this.getDataChildrenKeys(data)), false).filter(function (key, i, a) { return a.indexOf(key) === i; });
                            }
                        }
                        else {
                            if (!isRadio) {
                                selectedRowKeys = this.state.selectedRowKeys.filter(function (key) {
                                    return !tslib.__spreadArray([data[defaultKey]], tslib.__read(_this.getDataChildrenKeys(data)), false).includes(key);
                                });
                            }
                        }
                        if (!onSelect) return [3 /*break*/, 2];
                        selectedResult = this.getSelectedRows(this.state.dataSource, selectedRowKeys);
                        return [4 /*yield*/, onSelect(selectedResult.selectedRows, selectedRowKeys, selectedResult.unSelectedRows)];
                    case 1:
                        prevented = _b.sent();
                        if (prevented) {
                            return [2 /*return*/];
                        }
                        _b.label = 2;
                    case 2:
                        this.setState({ selectedRowKeys: selectedRowKeys });
                        return [2 /*return*/];
                }
            });
        });
    };
    Table.prototype.renderRow = function (data, rowIndex, levels) {
        var _this = this;
        var _a = this.props, cx = _a.classnames, rowSelection = _a.rowSelection, expandable = _a.expandable, draggable = _a.draggable, indentSize = _a.indentSize, rowClassName = _a.rowClassName, keyField = _a.keyField, lineHeight = _a.lineHeight // 是否设置了固定行高
        ;
        var tdColumns = this.tdColumns;
        var isExpandable = this.isExpandableTable();
        var defaultKey = this.getRowSelectionKeyField();
        var colCount = this.getExtraColumnCount();
        var isLeftExpandable = this.isLeftExpandable();
        var isRightExpandable = this.isRightExpandable();
        // 当前行是否可展开
        var isExpandableRow = this.isExpandableRow(data, rowIndex);
        // 当前行是否有children
        var hasChildrenRow = this.hasChildrenRow(data);
        var isExpanded = this.isExpanded(data);
        // 设置缩进效果
        var indentDom = levels.length > 0 ? (React__default["default"].createElement("span", { className: cx('Table-row-indent', "indent-level-".concat(levels.length)), style: levels.length > 0
                ? { paddingLeft: indentSize * levels.length + 'px' }
                : {} })) : null;
        var cells = tdColumns.map(function (item, i) {
            var _a, _b;
            var render = item.render && typeof item.render === 'function'
                ? item.render(data[item.name], data, rowIndex, i)
                : null;
            var props = { rowSpan: 1, colSpan: 1 };
            var children = render;
            if (render && amisCore.isObject(render)) {
                props = render.props;
                children = render.children;
                // 如果合并行 且有展开行，那么合并行不生效
                if (props.rowSpan > 1 && isExpandableRow && hasChildrenRow) {
                    props.rowSpan === 1;
                }
            }
            var className = typeof item.className === 'function'
                ? item.className(data, rowIndex)
                : '';
            return props.rowSpan === 0 || props.colSpan === 0 ? null : (React__default["default"].createElement(Cell["default"], tslib.__assign({ key: i }, props, { fixed: item.fixed === true ? 'left' : item.fixed, column: item, groupId: item.groupId, className: cx((_a = {},
                    _a["".concat(className)] = !!className,
                    _a)) }),
                React__default["default"].createElement("div", { className: cx('Table-cell-wrapper', (_b = {},
                        _b[cx('Table-cell-wrapper-prefix')] = i === 0 &&
                            (!!indentDom || (levels.length === 0 && hasChildrenRow)),
                        _b[cx("Table-cell-height-".concat(lineHeight))] = !!lineHeight,
                        _b)) },
                    i === 0 && levels.length > 0 ? indentDom : null,
                    i === 0 && hasChildrenRow ? _this.getExpandedIcons(data) : null,
                    render ? children : data[item.name])));
        });
        var rowClassNameClass = rowClassName && typeof rowClassName === 'function'
            ? rowClassName(data, rowIndex)
            : '';
        // 可展开和嵌套不能同时支持
        // 设置了expandable 数据源里有children也就不生效了
        // 拖拽排序 可选、可展开都先不支持了，可以支持嵌套展示
        var checkboxProps = rowSelection && rowSelection.getCheckboxProps
            ? rowSelection.getCheckboxProps(data, rowIndex)
            : {};
        var expandedRowClassName = expandable &&
            expandable.expandedRowClassName &&
            typeof expandable.expandedRowClassName === 'function'
            ? expandable.expandedRowClassName(data, rowIndex)
            : '';
        var dataKey = this.getChildrenColumnName();
        var children = !draggable && isExpandableRow && isExpanded ? (React__default["default"].createElement("tr", { key: "expanded", className: cx('Table-expanded-row', expandedRowClassName) },
            React__default["default"].createElement(Cell["default"], { colSpan: tdColumns.length + colCount }, expandable &&
                expandable.expandedRowRender &&
                typeof expandable.expandedRowRender === 'function'
                ? expandable.expandedRowRender(data, rowIndex)
                : null))) : this.hasChildrenRow(data) && isExpanded ? (data[dataKey].map(function (item, index) {
            return _this.renderRow(item, index, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(levels), false), [rowIndex], false));
        })) : null;
        var isChecked = !!find__default["default"](this.state.selectedRowKeys, function (key) { return key === data[defaultKey]; });
        var hasChildrenChecked = this.hasCheckedChildrenRows(data);
        var isRadio = rowSelection && rowSelection.type === 'radio';
        var expandableCell = !draggable && isExpandable ? (React__default["default"].createElement(Cell["default"], { fixed: expandable && expandable.fixed
                ? isRightExpandable
                    ? 'right'
                    : 'left'
                : '', className: cx('Table-cell-expand-icon-cell') }, isExpandableRow || hasChildrenRow
            ? this.getExpandedIcons(data)
            : null)) : null;
        return [
            React__default["default"].createElement("tr", { key: "".concat(data[keyField || 'key'] || rowIndex), "row-index": rowIndex, "row-levels": levels.join(','), className: cx('Table-row', "Table-row-level-".concat(levels.length), rowClassNameClass, {
                    'Table-row-disabled': !!checkboxProps.disabled
                }), onMouseEnter: function (e) { return _this.onRowMouseEnter(e, data, rowIndex); }, onMouseLeave: function (e) { return _this.onRowMouseLeave(e, data, rowIndex); }, onClick: function (e) { return _this.onRowClick(e, data, rowIndex); } },
                draggable ? (React__default["default"].createElement(Cell["default"], { className: cx('Table-dragCell') },
                    React__default["default"].createElement(icons.Icon, { icon: "drag-bar", className: "icon" }))) : null,
                !draggable && rowSelection ? (React__default["default"].createElement(Cell["default"], { fixed: rowSelection.fixed ? 'left' : '', className: cx('Table-checkCell') },
                    React__default["default"].createElement(Checkbox["default"], tslib.__assign({ name: 'Table-checkbox', type: rowSelection.type || 'checkbox', partial: !isRadio && hasChildrenChecked && !isChecked, checked: isRadio ? isChecked : hasChildrenChecked || isChecked, onChange: function (value) {
                            if (!(rowSelection && rowSelection.rowClick)) {
                                _this.selectedSingleRow(value, data);
                            }
                            event && event.stopPropagation();
                        } }, checkboxProps)))) : null,
                isLeftExpandable ? expandableCell : null,
                cells,
                isRightExpandable ? expandableCell : null),
            children
        ];
    };
    Table.prototype.renderTBody = function () {
        var _this = this;
        var _a = this.props, cx = _a.classnames, headSummary = _a.headSummary, scroll = _a.scroll, placeholder = _a.placeholder, sticky = _a.sticky;
        var tdColumns = this.tdColumns;
        var hasScrollY = scroll && scroll.y;
        var colCount = this.getExtraColumnCount();
        return (React__default["default"].createElement("tbody", { ref: this.tbodyDom, className: cx('Table-tbody') },
            !hasScrollY && !sticky && headSummary
                ? this.renderSummaryRow(headSummary)
                : null,
            !this.state.dataSource.length ? (React__default["default"].createElement("tr", { className: cx('Table-row', 'Table-empty-row') },
                React__default["default"].createElement(Cell["default"], { colSpan: tdColumns.length + colCount },
                    React__default["default"].createElement("div", { className: cx('Table-empty') }, typeof placeholder === 'function'
                        ? placeholder()
                        : placeholder)))) : (this.state.dataSource.map(function (data, index) {
                return _this.renderRow(data, index, []);
            }))));
    };
    Table.prototype.isExpandableTable = function () {
        var expandable = this.props.expandable;
        // 设置了expandable 优先级更高
        // 就不支持默认嵌套了
        return !!expandable;
    };
    // 展开列放到右侧 会影响之前的一些合并的规则
    Table.prototype.isRightExpandable = function () {
        var expandable = this.props.expandable;
        return expandable && expandable.position === 'right';
    };
    // 展开列放到左侧
    Table.prototype.isLeftExpandable = function () {
        var expandable = this.props.expandable;
        return (expandable && (!expandable.position || expandable.position === 'left'));
    };
    Table.prototype.isNestedTable = function () {
        var _this = this;
        var dataSource = this.props.dataSource;
        return !!find__default["default"](dataSource, function (item) { return _this.hasChildrenRow(item); });
    };
    // 计算自动增加的列数
    // 选择、拖拽、展开
    Table.prototype.getExtraColumnCount = function () {
        var _a = this.props, draggable = _a.draggable, rowSelection = _a.rowSelection, expandable = _a.expandable;
        var count = 0;
        if (draggable) {
            count++;
        }
        else {
            if (this.isExpandableTable() && (expandable === null || expandable === void 0 ? void 0 : expandable.position) !== 'none') {
                count++;
            }
            if (rowSelection) {
                count++;
            }
        }
        return count;
    };
    Table.prototype.renderSummaryRow = function (summary) {
        var _this = this;
        var _a = this.props, cx = _a.classnames, dataSource = _a.dataSource;
        var cells = [];
        var trs = [];
        var colCount = this.getExtraColumnCount();
        var isRightExpandable = this.isRightExpandable() ? 1 : 0;
        Array.isArray(summary)
            ? summary.forEach(function (s, index) {
                Array.isArray(s)
                    ? trs.push(React__default["default"].createElement("tr", { onMouseEnter: function (e) { return _this.onRowMouseEnter(e); }, onMouseLeave: function (e) { return _this.onRowMouseLeave(e); }, key: 'summary-tr-' + index, className: cx('Table-summary-row') }, s.map(function (d, i) {
                        // 将操作列自动添加到第一列，用户的colSpan只需要关心实际的列数
                        var colSpan = i === 0
                            ? (d.colSpan || 1) + colCount - isRightExpandable
                            : i === s.length - 1
                                ? (d.colSpan || 1) + isRightExpandable
                                : d.colSpan;
                        return (React__default["default"].createElement(Cell["default"], { key: 'summary-tr-cell-' + i, fixed: d.fixed, colSpan: colSpan }, typeof d.render === 'function'
                            ? d.render(dataSource)
                            : d.render));
                    })))
                    : cells.push(React__default["default"].createElement(Cell["default"], { key: 'summary-cell-' + index, fixed: s.fixed, colSpan: cells.length === 0
                            ? (s.colSpan || 1) + colCount - isRightExpandable
                            : index === summary.length - 1
                                ? (s.colSpan || 1) + isRightExpandable
                                : s.colSpan }, typeof s.render === 'function'
                        ? s.render(dataSource)
                        : s.render));
            })
            : null;
        return summary
            ? typeof summary === 'function'
                ? summary(dataSource)
                : tslib.__spreadArray([
                    cells.length > 0 ? (React__default["default"].createElement("tr", { onMouseEnter: function (e) { return _this.onRowMouseEnter(e); }, onMouseLeave: function (e) { return _this.onRowMouseLeave(e); }, key: "summary-row", className: cx('Table-summary-row') }, cells)) : null
                ], tslib.__read(trs), false)
            : null;
    };
    Table.prototype.renderTFoot = function () {
        var _a = this.props, cx = _a.classnames, footSummary = _a.footSummary;
        return (React__default["default"].createElement("tfoot", { ref: this.tfootDom, className: cx('Table-summary') }, this.renderSummaryRow(footSummary)));
    };
    Table.prototype.updateTableDom = function (dom) {
        var cx = this.props.classnames;
        var scrollLeft = dom.scrollLeft, scrollWidth = dom.scrollWidth, offsetWidth = dom.offsetWidth;
        var table = this.tableDom.current;
        var leftCalss = cx('Table-ping-left');
        if (scrollLeft > 0) {
            table === null || table === void 0 ? void 0 : table.classList.add(leftCalss);
        }
        else {
            table === null || table === void 0 ? void 0 : table.classList.remove(leftCalss);
        }
        var rightClass = cx('Table-ping-right');
        if (scrollLeft + offsetWidth < scrollWidth) {
            table === null || table === void 0 ? void 0 : table.classList.add(rightClass);
        }
        else {
            table === null || table === void 0 ? void 0 : table.classList.remove(rightClass);
        }
    };
    Table.prototype.onTableContentScroll = function (event) {
        this.updateTableDom(event.target);
    };
    Table.prototype.onWheel = function (event) {
        var _a = event, currentTarget = _a.currentTarget, deltaX = _a.deltaX;
        if (deltaX) {
            this.onTableScroll({
                target: currentTarget,
                scrollLeft: currentTarget.scrollLeft + deltaX
            });
            event.preventDefault();
        }
    };
    Table.prototype.onTableScroll = function (event) {
        var scrollDomRefs = [this.headerDom, this.bodyDom, this.footDom];
        var target = event.target, scrollLeft = event.scrollLeft;
        scrollDomRefs.forEach(function (ref) {
            var current = ref && ref.current;
            if (current && current !== target) {
                current.scrollLeft = scrollLeft || target.scrollLeft;
            }
        });
        this.updateTableDom(target);
    };
    Table.prototype.renderLoading = function () {
        var _a = this.props, cx = _a.classnames, loading = _a.loading, loadingConfig = _a.loadingConfig;
        return (React__default["default"].createElement("div", { className: cx('Table-loading') }, typeof loading === 'boolean' ? (React__default["default"].createElement(Spinner["default"], { loadingConfig: loadingConfig })) : (loading)));
    };
    Table.prototype.renderTable = function () {
        var _a = this.props, scroll = _a.scroll, footSummary = _a.footSummary, loading = _a.loading, showHeader = _a.showHeader, itemActions = _a.itemActions, cx = _a.classnames;
        // 设置了横向滚动轴 则table的table-layout为fixed
        var hasScrollX = scroll && scroll.x;
        var hoverRow = this.state.hoverRow;
        var tableLayout = hasScrollX ? 'fixed' : 'auto';
        var tableStyle = hasScrollX ? { width: scroll.x + 'px' } : {};
        return (React__default["default"].createElement("div", { ref: this.contentDom, className: cx('Table-content'), style: hasScrollX ? { overflow: 'auto hidden' } : {}, onMouseLeave: this.onMouseLeave.bind(this), onScroll: this.onTableContentScroll.bind(this) },
            itemActions && hoverRow ? (React__default["default"].createElement(ItemActionsWrapper["default"], { dom: hoverRow.target, classnames: cx }, typeof itemActions === 'function'
                ? itemActions(hoverRow.record, hoverRow.rowIndex)
                : null)) : null,
            React__default["default"].createElement("table", { style: tslib.__assign(tslib.__assign({}, tableStyle), { tableLayout: tableLayout }), className: cx('Table-table') },
                this.renderColGroup(),
                showHeader ? this.renderTHead() : null,
                !loading ? this.renderTBody() : null,
                !loading && footSummary ? this.renderTFoot() : null),
            loading ? this.renderLoading() : null));
    };
    Table.prototype.renderScrollTableHeader = function () {
        var _a;
        var _b = this.props, scroll = _b.scroll, headSummary = _b.headSummary, sticky = _b.sticky, showHeader = _b.showHeader, cx = _b.classnames;
        var style = { overflow: 'hidden' };
        if (!!sticky) {
            Object.assign(style, { top: 0 });
        }
        var tableStyle = {};
        if (scroll && (scroll.y || scroll.x)) {
            Object.assign(tableStyle, {
                width: scroll && scroll.x ? scroll.x + 'px' : '100%',
                tableLayout: 'fixed'
            });
        }
        return (React__default["default"].createElement("div", { ref: this.headerDom, className: cx('Table-header', (_a = {},
                _a[cx('Table-sticky-holder')] = !!sticky,
                _a)), style: style },
            React__default["default"].createElement("table", { className: cx('Table-table'), style: tableStyle },
                this.renderColGroup(this.state.colWidths),
                showHeader ? this.renderTHead() : null,
                headSummary ? (React__default["default"].createElement("tbody", null, this.renderSummaryRow(headSummary))) : null)));
    };
    Table.prototype.renderScrollTableBody = function () {
        var _a = this.props, scroll = _a.scroll, itemActions = _a.itemActions, cx = _a.classnames;
        var style = {};
        var tableStyle = {};
        if (scroll && (scroll.y || scroll.x)) {
            Object.assign(style, {
                overflow: 'auto scroll',
                maxHeight: scroll.y
            });
            Object.assign(tableStyle, {
                width: scroll && scroll.x ? scroll.x + 'px' : '100%',
                tableLayout: 'fixed'
            });
        }
        var hoverRow = this.state.hoverRow;
        return (React__default["default"].createElement("div", { ref: this.bodyDom, className: cx('Table-body'), style: style, onMouseLeave: this.onMouseLeave.bind(this), onScroll: this.onTableScroll.bind(this) },
            itemActions && hoverRow ? (React__default["default"].createElement(ItemActionsWrapper["default"], { dom: hoverRow.target, classnames: cx }, typeof itemActions === 'function'
                ? itemActions(hoverRow.record, hoverRow.rowIndex)
                : null)) : null,
            React__default["default"].createElement("table", { className: cx('Table-table'), style: tableStyle },
                this.renderColGroup(),
                this.renderTBody())));
    };
    Table.prototype.renderScrollTableFoot = function () {
        var _a = this.props, scroll = _a.scroll, cx = _a.classnames;
        return (React__default["default"].createElement("div", { ref: this.footDom, className: cx('Table-summary'), style: { overflow: 'hidden' } },
            React__default["default"].createElement("table", { className: cx('Table-table'), style: { width: (scroll === null || scroll === void 0 ? void 0 : scroll.x) + 'px' || '100%', tableLayout: 'fixed' } }, this.renderTFoot())));
    };
    Table.prototype.renderScrollTable = function () {
        var _a = this.props, footSummary = _a.footSummary, loading = _a.loading, cx = _a.classnames;
        return (React__default["default"].createElement("div", { className: cx('Table-container') },
            this.renderScrollTableHeader(),
            !loading ? this.renderScrollTableBody() : null,
            !loading && footSummary ? this.renderScrollTableFoot() : null,
            loading ? this.renderLoading() : null));
    };
    Table.prototype.render = function () {
        var _a;
        var _b = this.props, title = _b.title, footer = _b.footer, className = _b.className, scroll = _b.scroll, size = _b.size, bordered = _b.bordered, resizable = _b.resizable, columns = _b.columns, sticky = _b.sticky, cx = _b.classnames;
        // 过滤掉设置了breakpoint属性的列
        var filterColumns = columns.filter(function (item) { return !item.breakpoint || !amisCore.isBreakpoint(item.breakpoint); });
        this.thColumns = [];
        this.tdColumns = [];
        buildColumns(filterColumns, this.thColumns, this.tdColumns, getMaxLevelThRowSpan(filterColumns));
        // 是否设置了纵向滚动
        var hasScrollY = scroll && scroll.y;
        // 是否设置了横向滚动
        var hasScrollX = scroll && scroll.x;
        return (React__default["default"].createElement("div", { ref: this.tableDom, className: cx('Table2', className, (_a = {},
                _a[cx('Table-scroll-horizontal')] = hasScrollX,
                _a[cx("Table-".concat(size))] = size,
                _a[cx('Table-bordered')] = bordered,
                _a[cx('Table-resizable')] = resizable,
                _a)) },
            title ? (React__default["default"].createElement("div", { className: cx('Table-title') }, typeof title === 'function' ? title() : title)) : null,
            hasScrollY || sticky ? (this.renderScrollTable()) : (React__default["default"].createElement("div", { className: cx('Table-container') }, this.renderTable())),
            footer ? (React__default["default"].createElement("div", { className: cx('Table-footer') }, typeof footer === 'function' ? footer() : footer)) : null));
    };
    Table.defaultProps = {
        title: '',
        className: '',
        dataSource: [],
        columns: [],
        indentSize: 15,
        placeholder: '暂无数据',
        showHeader: true
    };
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], Table.prototype, "getPopOverContainer", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], Table.prototype, "onResizeMouseMove", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [MouseEvent]),
        tslib.__metadata("design:returntype", void 0)
    ], Table.prototype, "onResizeMouseUp", null);
    return Table;
}(React__default["default"].PureComponent));
var index = amisCore.themeable(amisCore.localeable(Table));

exports.Table = Table;
exports["default"] = index;
