import { __values } from '../../../node_modules/tslib/tslib.es6.js';
import { getVal, getValNumber, getValBoolean } from '../../../OpenXML.js';
import { Paragraph } from '../Paragraph.js';
import { Table } from '../Table.js';
import { parseSize, LengthUsage } from '../../../parse/parseSize.js';
import { parseShdColor } from '../../../parse/parseColor.js';
import { parseBorders, parseBorder } from '../../../parse/parseBorder.js';
import { parseTextDirection } from '../../../parse/parseTextDirection.js';
import { ST_Merge, ST_VerticalJc, ST_TblWidth } from '../../Types.js';

// http://officeopenxml.com/WPtableCellProperties-Margins.php
function parseCellMargin(element, style) {
    var e_1, _a;
    try {
        for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var tagName = child.tagName;
            switch (tagName) {
                case 'w:left':
                case 'w:start':
                    style['padding-left'] = parseSize(child, 'w:w');
                    break;
                case 'w:right':
                case 'w:end':
                    style['padding-right'] = parseSize(child, 'w:w');
                    break;
                case 'w:top':
                    style['padding-top'] = parseSize(child, 'w:w');
                    break;
                case 'w:bottom':
                    style['padding-bottom'] = parseSize(child, 'w:w');
                    break;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
function parseVAlign(element, style) {
    var vAlign = getVal(element);
    switch (vAlign) {
        case ST_VerticalJc.bottom:
            style['vertical-align'] = 'bottom';
            break;
        case ST_VerticalJc.center:
            style['vertical-align'] = 'middle';
            break;
        case ST_VerticalJc.top:
            style['vertical-align'] = 'top';
            break;
    }
}
function parseTblCellSpacing(element, style) {
    var width = parseTblWidth(element);
    if (width) {
        style['cell-spacing'] = width;
    }
}
/**
 * parseBorders 不支持 insideH 和 insideV，所以单独支持一下
 * 实际显示时需要过滤掉第一列
 */
function parseInsideBorders(word, element) {
    var H;
    var insideH = element.querySelector('insideH');
    if (insideH) {
        H = parseBorder(word, insideH);
    }
    var V;
    var insideV = element.querySelector('insideV');
    if (insideV) {
        V = parseBorder(word, insideV);
    }
    return {
        H: H,
        V: V
    };
}
/**
 * http://officeopenxml.com/WPtableWidth.php
 */
function parseTblWidth(element) {
    var type = element.getAttribute('w:type');
    if (!type || type === ST_TblWidth.dxa) {
        return parseSize(element, 'w:w');
    }
    else if (type === ST_TblWidth.pct) {
        return parseSize(element, 'w:w', LengthUsage.Percent);
    }
    else if (type === ST_TblWidth.auto) {
        return 'auto';
    }
    else {
        console.warn('parseTblWidth: ignore type', type, element);
    }
    return '';
}
function parseTcW(element, style) {
    var width = parseTblWidth(element);
    if (width) {
        style.width = width;
    }
}
var Tc = /** @class */ (function () {
    function Tc() {
        this.properties = {};
        this.children = [];
    }
    Tc.prototype.add = function (child) {
        if (child) {
            this.children.push(child);
        }
    };
    Tc.parseTcPr = function (word, element) {
        var e_2, _a;
        var properties = {};
        var style = {};
        properties.cssStyle = style;
        try {
            for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                var tagName = child.tagName;
                switch (tagName) {
                    case 'w:tcMar':
                        parseCellMargin(child, style);
                        break;
                    case 'w:shd':
                        style['background-color'] = parseShdColor(word, child);
                        break;
                    case 'w:tcW':
                        parseTcW(child, style);
                        break;
                    case 'w:noWrap':
                        // http://webapp.docx4java.org/OnlineDemo/ecma376/WordML/noWrap.html
                        var noWrap = getValBoolean(child);
                        if (noWrap) {
                            style['white-space'] = 'nowrap';
                        }
                        break;
                    case 'w:vAlign':
                        parseVAlign(child, style);
                        break;
                    case 'w:tcBorders':
                        parseBorders(word, child, style);
                        properties.insideBorder = parseInsideBorders(word, child);
                        break;
                    case 'w:gridSpan':
                        properties.gridSpan = getValNumber(child);
                        break;
                    case 'w:vMerge':
                        properties.vMerge = getVal(child) || ST_Merge.continue;
                        break;
                    case 'w:textDirection':
                        parseTextDirection(child, style);
                        break;
                    case 'w:cnfStyle':
                        // 目前是自动计算的，所以不需要这个了
                        break;
                    default:
                        console.warn('parseTcPr: ignore', tagName, child);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return properties;
    };
    Tc.fromXML = function (word, element, currentCol, rowSpanMap) {
        var e_3, _a;
        var tc = new Tc();
        try {
            for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                var tagName = child.tagName;
                switch (tagName) {
                    case 'w:tcPr':
                        tc.properties = Tc.parseTcPr(word, child);
                        break;
                    case 'w:p':
                        tc.add(Paragraph.fromXML(word, child));
                        break;
                    case 'w:tbl':
                        tc.add(Table.fromXML(word, child));
                        break;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var lastCol = rowSpanMap[currentCol.index];
        // 如果是 continue 意味着这个被合并了
        if (tc.properties.vMerge) {
            if (tc.properties.vMerge === ST_Merge.restart) {
                tc.properties.rowSpan = 1;
                rowSpanMap[currentCol.index] = tc;
            }
            else if (lastCol) {
                if (lastCol.properties && lastCol.properties.rowSpan) {
                    lastCol.properties.rowSpan = lastCol.properties.rowSpan + 1;
                    var colSpan_1 = tc.properties.gridSpan || 1;
                    currentCol.index += colSpan_1;
                    return null;
                }
                else {
                    console.warn('Tc.fromXML: continue but not found lastCol', currentCol.index, tc, rowSpanMap);
                }
            }
        }
        else {
            delete rowSpanMap[currentCol.index];
        }
        var colSpan = tc.properties.gridSpan || 1;
        currentCol.index += colSpan;
        return tc;
    };
    return Tc;
}());

export { Tc, parseCellMargin, parseInsideBorders, parseTblCellSpacing, parseTblWidth };
